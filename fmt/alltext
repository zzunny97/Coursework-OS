0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NINODE       50  
0156 #define NDEV         10  
0157 #define ROOTDEV       1  
0158 #define MAXARG       32  
0159 #define MAXOPBLOCKS  10  
0160 #define LOGSIZE      (MAXOPBLOCKS*3)  
0161 #define NBUF         (MAXOPBLOCKS*3)  
0162 #define FSSIZE       1000  
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0xE000000           
0204 #define DEVSPACE 0xFE000000         
0205 
0206 
0207 #define KERNBASE 0x80000000         
0208 #define KERNLINK (KERNBASE+EXTMEM)  
0209 
0210 #define V2P(a) (((uint) (a)) - KERNBASE)
0211 #define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
0212 
0213 #define V2P_WO(x) ((x) - KERNBASE)    
0214 #define P2V_WO(x) ((x) + KERNBASE)    
0215 
0216 
0217 
0218 
0219 
0220 
0221 
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct rtcdate;
0257 struct spinlock;
0258 struct sleeplock;
0259 struct stat;
0260 struct superblock;
0261 
0262 
0263 void            binit(void);
0264 struct buf*     bread(uint, uint);
0265 void            brelse(struct buf*);
0266 void            bwrite(struct buf*);
0267 
0268 
0269 void            consoleinit(void);
0270 void            cprintf(char*, ...);
0271 void            consoleintr(int(*)(void));
0272 void            panic(char*) __attribute__((noreturn));
0273 
0274 
0275 int             exec(char*, char**);
0276 
0277 
0278 struct file*    filealloc(void);
0279 void            fileclose(struct file*);
0280 struct file*    filedup(struct file*);
0281 void            fileinit(void);
0282 int             fileread(struct file*, char*, int n);
0283 int             filestat(struct file*, struct stat*);
0284 int             filewrite(struct file*, char*, int n);
0285 
0286 
0287 void            readsb(int dev, struct superblock *sb);
0288 int             dirlink(struct inode*, char*, uint);
0289 struct inode*   dirlookup(struct inode*, char*, uint*);
0290 struct inode*   ialloc(uint, short);
0291 struct inode*   idup(struct inode*);
0292 void            iinit(int dev);
0293 void            ilock(struct inode*);
0294 void            iput(struct inode*);
0295 void            iunlock(struct inode*);
0296 void            iunlockput(struct inode*);
0297 void            iupdate(struct inode*);
0298 int             namecmp(const char*, const char*);
0299 struct inode*   namei(char*);
0300 struct inode*   nameiparent(char*, char*);
0301 int             readi(struct inode*, char*, uint, uint);
0302 void            stati(struct inode*, struct stat*);
0303 int             writei(struct inode*, char*, uint, uint);
0304 
0305 
0306 void            ideinit(void);
0307 void            ideintr(void);
0308 void            iderw(struct buf*);
0309 
0310 
0311 void            ioapicenable(int irq, int cpu);
0312 extern uchar    ioapicid;
0313 void            ioapicinit(void);
0314 
0315 
0316 char*           kalloc(void);
0317 void            kfree(char*);
0318 void            kinit1(void*, void*);
0319 void            kinit2(void*, void*);
0320 
0321 
0322 void            kbdintr(void);
0323 
0324 
0325 void            cmostime(struct rtcdate *r);
0326 int             lapicid(void);
0327 extern volatile uint*    lapic;
0328 void            lapiceoi(void);
0329 void            lapicinit(void);
0330 void            lapicstartap(uchar, uint);
0331 void            microdelay(int);
0332 
0333 
0334 void            initlog(int dev);
0335 void            log_write(struct buf*);
0336 void            begin_op();
0337 void            end_op();
0338 
0339 
0340 extern int      ismp;
0341 void            mpinit(void);
0342 
0343 
0344 void            picenable(int);
0345 void            picinit(void);
0346 
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 
0358 int             cpuid(void);
0359 void            exit(void);
0360 int             fork(void);
0361 int             growproc(int);
0362 int             kill(int);
0363 struct cpu*     mycpu(void);
0364 struct proc*    myproc();
0365 void            pinit(void);
0366 void            procdump(void);
0367 void            scheduler(void) __attribute__((noreturn));
0368 void            sched(void);
0369 void            setproc(struct proc*);
0370 void            sleep(void*, struct spinlock*);
0371 void            userinit(void);
0372 int             wait(void);
0373 void            wakeup(void*);
0374 void            yield(void);
0375 int				      getnice(int);
0376 int				      setnice(int, int);
0377 void            ps(int);
0378 int             thread_create(void* (void*), void*, void*);
0379 void            thread_exit(void*);
0380 int             thread_join(int, void**);
0381 int             gettid();
0382 
0383 void            swtch(struct context**, struct context*);
0384 
0385 
0386 void            acquire(struct spinlock*);
0387 void            getcallerpcs(void*, uint*);
0388 int             holding(struct spinlock*);
0389 void            initlock(struct spinlock*, char*);
0390 void            release(struct spinlock*);
0391 void            pushcli(void);
0392 void            popcli(void);
0393 
0394 
0395 void            acquiresleep(struct sleeplock*);
0396 void            releasesleep(struct sleeplock*);
0397 int             holdingsleep(struct sleeplock*);
0398 void            initsleeplock(struct sleeplock*, char*);
0399 
0400 
0401 int             memcmp(const void*, const void*, uint);
0402 void*           memmove(void*, const void*, uint);
0403 void*           memset(void*, int, uint);
0404 char*           safestrcpy(char*, const char*, int);
0405 int             strlen(const char*);
0406 int             strncmp(const char*, const char*, uint);
0407 char*           strncpy(char*, const char*, int);
0408 
0409 
0410 int             argint(int, int*);
0411 int             argptr(int, char**, int);
0412 int             argstr(int, char**);
0413 int             fetchint(uint, int*);
0414 int             fetchstr(uint, char**);
0415 void            syscall(void);
0416 
0417 
0418 void            timerinit(void);
0419 
0420 
0421 void            idtinit(void);
0422 extern uint     ticks;
0423 void            tvinit(void);
0424 extern struct spinlock tickslock;
0425 
0426 
0427 void            uartinit(void);
0428 void            uartintr(void);
0429 void            uartputc(int);
0430 
0431 
0432 void            seginit(void);
0433 void            kvmalloc(void);
0434 pde_t*          setupkvm(void);
0435 char*           uva2ka(pde_t*, char*);
0436 int             allocuvm(pde_t*, uint, uint);
0437 int             deallocuvm(pde_t*, uint, uint);
0438 void            freevm(pde_t*);
0439 void            inituvm(pde_t*, char*, uint);
0440 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0441 pde_t*          copyuvm(pde_t*, uint);
0442 void            switchuvm(struct proc*);
0443 void            switchkvm(void);
0444 int             copyout(pde_t*, uint, void*, uint);
0445 void            clearpteu(pde_t *pgdir, char *uva);
0446 
0447 
0448 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0449 
0450 
0451 
0452 static inline uchar
0453 inb(ushort port)
0454 {
0455   uchar data;
0456 
0457   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0458   return data;
0459 }
0460 
0461 static inline void
0462 insl(int port, void *addr, int cnt)
0463 {
0464   asm volatile("cld; rep insl" :
0465                "=D" (addr), "=c" (cnt) :
0466                "d" (port), "0" (addr), "1" (cnt) :
0467                "memory", "cc");
0468 }
0469 
0470 static inline void
0471 outb(ushort port, uchar data)
0472 {
0473   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0474 }
0475 
0476 static inline void
0477 outw(ushort port, ushort data)
0478 {
0479   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0480 }
0481 
0482 static inline void
0483 outsl(int port, const void *addr, int cnt)
0484 {
0485   asm volatile("cld; rep outsl" :
0486                "=S" (addr), "=c" (cnt) :
0487                "d" (port), "0" (addr), "1" (cnt) :
0488                "cc");
0489 }
0490 
0491 static inline void
0492 stosb(void *addr, int data, int cnt)
0493 {
0494   asm volatile("cld; rep stosb" :
0495                "=D" (addr), "=c" (cnt) :
0496                "0" (addr), "1" (cnt), "a" (data) :
0497                "memory", "cc");
0498 }
0499 
0500 static inline void
0501 stosl(void *addr, int data, int cnt)
0502 {
0503   asm volatile("cld; rep stosl" :
0504                "=D" (addr), "=c" (cnt) :
0505                "0" (addr), "1" (cnt), "a" (data) :
0506                "memory", "cc");
0507 }
0508 
0509 struct segdesc;
0510 
0511 static inline void
0512 lgdt(struct segdesc *p, int size)
0513 {
0514   volatile ushort pd[3];
0515 
0516   pd[0] = size-1;
0517   pd[1] = (uint)p;
0518   pd[2] = (uint)p >> 16;
0519 
0520   asm volatile("lgdt (%0)" : : "r" (pd));
0521 }
0522 
0523 struct gatedesc;
0524 
0525 static inline void
0526 lidt(struct gatedesc *p, int size)
0527 {
0528   volatile ushort pd[3];
0529 
0530   pd[0] = size-1;
0531   pd[1] = (uint)p;
0532   pd[2] = (uint)p >> 16;
0533 
0534   asm volatile("lidt (%0)" : : "r" (pd));
0535 }
0536 
0537 static inline void
0538 ltr(ushort sel)
0539 {
0540   asm volatile("ltr %0" : : "r" (sel));
0541 }
0542 
0543 static inline uint
0544 readeflags(void)
0545 {
0546   uint eflags;
0547   asm volatile("pushfl; popl %0" : "=r" (eflags));
0548   return eflags;
0549 }
0550 static inline void
0551 loadgs(ushort v)
0552 {
0553   asm volatile("movw %0, %%gs" : : "r" (v));
0554 }
0555 
0556 static inline void
0557 cli(void)
0558 {
0559   asm volatile("cli");
0560 }
0561 
0562 static inline void
0563 sti(void)
0564 {
0565   asm volatile("sti");
0566 }
0567 
0568 static inline uint
0569 xchg(volatile uint *addr, uint newval)
0570 {
0571   uint result;
0572 
0573   
0574   asm volatile("lock; xchgl %0, %1" :
0575                "+m" (*addr), "=a" (result) :
0576                "1" (newval) :
0577                "cc");
0578   return result;
0579 }
0580 
0581 static inline uint
0582 rcr2(void)
0583 {
0584   uint val;
0585   asm volatile("movl %%cr2,%0" : "=r" (val));
0586   return val;
0587 }
0588 
0589 static inline void
0590 lcr3(uint val)
0591 {
0592   asm volatile("movl %0,%%cr3" : : "r" (val));
0593 }
0594 
0595 
0596 
0597 
0598 
0599 
0600 
0601 
0602 struct trapframe {
0603   
0604   uint edi;
0605   uint esi;
0606   uint ebp;
0607   uint oesp;      
0608   uint ebx;
0609   uint edx;
0610   uint ecx;
0611   uint eax;
0612 
0613   
0614   ushort gs;
0615   ushort padding1;
0616   ushort fs;
0617   ushort padding2;
0618   ushort es;
0619   ushort padding3;
0620   ushort ds;
0621   ushort padding4;
0622   uint trapno;
0623 
0624   
0625   uint err;
0626   uint eip;
0627   ushort cs;
0628   ushort padding5;
0629   uint eflags;
0630 
0631   
0632   uint esp;
0633   ushort ss;
0634   ushort padding6;
0635 };
0636 
0637 
0638 
0639 
0640 
0641 
0642 
0643 
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 
0653 
0654 #define SEG_NULLASM                                             \
0655         .word 0, 0;                                             \
0656         .byte 0, 0, 0, 0
0657 
0658 
0659 
0660 #define SEG_ASM(type,base,lim)                                  \
0661         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0662         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0663                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0664 
0665 #define STA_X     0x8       
0666 #define STA_W     0x2       
0667 #define STA_R     0x2       
0668 
0669 
0670 
0671 
0672 
0673 
0674 
0675 
0676 
0677 
0678 
0679 
0680 
0681 
0682 
0683 
0684 
0685 
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define FL_IF           0x00000200      
0705 
0706 
0707 #define CR0_PE          0x00000001      
0708 #define CR0_WP          0x00010000      
0709 #define CR0_PG          0x80000000      
0710 
0711 #define CR4_PSE         0x00000010      
0712 
0713 
0714 #define SEG_KCODE 1  
0715 #define SEG_KDATA 2  
0716 #define SEG_UCODE 3  
0717 #define SEG_UDATA 4  
0718 #define SEG_TSS   5  
0719 
0720 
0721 #define NSEGS     6
0722 
0723 #ifndef __ASSEMBLER__
0724 
0725 struct segdesc {
0726   uint lim_15_0 : 16;  
0727   uint base_15_0 : 16; 
0728   uint base_23_16 : 8; 
0729   uint type : 4;       
0730   uint s : 1;          
0731   uint dpl : 2;        
0732   uint p : 1;          
0733   uint lim_19_16 : 4;  
0734   uint avl : 1;        
0735   uint rsv1 : 1;       
0736   uint db : 1;         
0737   uint g : 1;          
0738   uint base_31_24 : 8; 
0739 };
0740 
0741 
0742 
0743 
0744 
0745 
0746 
0747 
0748 
0749 
0750 
0751 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0752 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0753   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0754   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0755 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0756 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0757   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0758   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0759 #endif
0760 
0761 #define DPL_USER    0x3     
0762 
0763 
0764 #define STA_X       0x8     
0765 #define STA_W       0x2     
0766 #define STA_R       0x2     
0767 
0768 
0769 #define STS_T32A    0x9     
0770 #define STS_IG32    0xE     
0771 #define STS_TG32    0xF     
0772 
0773 
0774 
0775 
0776 
0777 
0778 
0779 
0780 
0781 
0782 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0783 
0784 
0785 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0786 
0787 
0788 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0789 
0790 
0791 #define NPDENTRIES      1024    
0792 #define NPTENTRIES      1024    
0793 #define PGSIZE          4096    
0794 
0795 #define PTXSHIFT        12      
0796 #define PDXSHIFT        22      
0797 
0798 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0799 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0800 
0801 #define PTE_P           0x001   
0802 #define PTE_W           0x002   
0803 #define PTE_U           0x004   
0804 #define PTE_PS          0x080   
0805 
0806 
0807 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0808 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
0809 
0810 #ifndef __ASSEMBLER__
0811 typedef uint pte_t;
0812 
0813 
0814 struct taskstate {
0815   uint link;         
0816   uint esp0;         
0817   ushort ss0;        
0818   ushort padding1;
0819   uint *esp1;
0820   ushort ss1;
0821   ushort padding2;
0822   uint *esp2;
0823   ushort ss2;
0824   ushort padding3;
0825   void *cr3;         
0826   uint *eip;         
0827   uint eflags;
0828   uint eax;          
0829   uint ecx;
0830   uint edx;
0831   uint ebx;
0832   uint *esp;
0833   uint *ebp;
0834   uint esi;
0835   uint edi;
0836   ushort es;         
0837   ushort padding4;
0838   ushort cs;
0839   ushort padding5;
0840   ushort ss;
0841   ushort padding6;
0842   ushort ds;
0843   ushort padding7;
0844   ushort fs;
0845   ushort padding8;
0846   ushort gs;
0847   ushort padding9;
0848   ushort ldt;
0849   ushort padding10;
0850   ushort t;          
0851   ushort iomb;       
0852 };
0853 
0854 
0855 struct gatedesc {
0856   uint off_15_0 : 16;   
0857   uint cs : 16;         
0858   uint args : 5;        
0859   uint rsv1 : 3;        
0860   uint type : 4;        
0861   uint s : 1;           
0862   uint dpl : 2;         
0863   uint p : 1;           
0864   uint off_31_16 : 16;  
0865 };
0866 
0867 
0868 
0869 
0870 
0871 
0872 
0873 
0874 
0875 #define SETGATE(gate, istrap, sel, off, d)                \
0876 {                                                         \
0877   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0878   (gate).cs = (sel);                                      \
0879   (gate).args = 0;                                        \
0880   (gate).rsv1 = 0;                                        \
0881   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0882   (gate).s = 0;                                           \
0883   (gate).dpl = (d);                                       \
0884   (gate).p = 1;                                           \
0885   (gate).off_31_16 = (uint)(off) >> 16;                  \
0886 }
0887 
0888 #endif
0889 
0890 
0891 
0892 
0893 
0894 
0895 
0896 
0897 
0898 
0899 
0900 
0901 
0902 #define ELF_MAGIC 0x464C457FU  
0903 
0904 
0905 struct elfhdr {
0906   uint magic;  
0907   uchar elf[12];
0908   ushort type;
0909   ushort machine;
0910   uint version;
0911   uint entry;
0912   uint phoff;
0913   uint shoff;
0914   uint flags;
0915   ushort ehsize;
0916   ushort phentsize;
0917   ushort phnum;
0918   ushort shentsize;
0919   ushort shnum;
0920   ushort shstrndx;
0921 };
0922 
0923 
0924 struct proghdr {
0925   uint type;
0926   uint off;
0927   uint vaddr;
0928   uint paddr;
0929   uint filesz;
0930   uint memsz;
0931   uint flags;
0932   uint align;
0933 };
0934 
0935 
0936 #define ELF_PROG_LOAD           1
0937 
0938 
0939 #define ELF_PROG_FLAG_EXEC      1
0940 #define ELF_PROG_FLAG_WRITE     2
0941 #define ELF_PROG_FLAG_READ      4
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 struct rtcdate {
0951   uint second;
0952   uint minute;
0953   uint hour;
0954   uint day;
0955   uint month;
0956   uint year;
0957 };
0958 
0959 
0960 
0961 
0962 
0963 
0964 
0965 
0966 
0967 
0968 
0969 
0970 
0971 
0972 
0973 
0974 
0975 
0976 
0977 
0978 
0979 
0980 
0981 
0982 
0983 
0984 
0985 
0986 
0987 
0988 
0989 
0990 
0991 
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 
1001 
1002 
1003 
1004 
1005 
1006 
1007 
1008 
1009 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 
1023 
1024 
1025 
1026 .p2align 2
1027 .text
1028 .globl multiboot_header
1029 multiboot_header:
1030   
1031   
1032   .long magic
1033   .long flags
1034   .long (-magic-flags)
1035 
1036 
1037 
1038 
1039 .globl _start
1040 _start = V2P_WO(entry)
1041 
1042 
1043 .globl entry
1044 entry:
1045   
1046   movl    %cr4, %eax
1047   orl     $(CR4_PSE), %eax
1048   movl    %eax, %cr4
1049   
1050   movl    $(V2P_WO(entrypgdir)), %eax
1051   movl    %eax, %cr3
1052   
1053   movl    %cr0, %eax
1054   orl     $(CR0_PG|CR0_WP), %eax
1055   movl    %eax, %cr0
1056 
1057   
1058   movl $(stack + KSTACKSIZE), %esp
1059 
1060   
1061   
1062   
1063   
1064   mov $main, %eax
1065   jmp *%eax
1066 
1067 .comm stack, KSTACKSIZE
1068 
1069 
1070 
1071 
1072 
1073 
1074 
1075 
1076 
1077 
1078 
1079 
1080 
1081 
1082 
1083 
1084 
1085 
1086 
1087 
1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096 
1097 
1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 
1109 
1110 
1111 
1112 
1113 
1114 
1115 
1116 
1117 
1118 
1119 
1120 
1121 .code16
1122 .globl start
1123 start:
1124   cli
1125 
1126   
1127   xorw    %ax,%ax
1128   movw    %ax,%ds
1129   movw    %ax,%es
1130   movw    %ax,%ss
1131 
1132   
1133   
1134   
1135   lgdt    gdtdesc
1136   movl    %cr0, %eax
1137   orl     $CR0_PE, %eax
1138   movl    %eax, %cr0
1139 
1140   
1141   
1142   
1143   ljmpl    $(SEG_KCODE<<3), $(start32)
1144 
1145 
1146 
1147 
1148 
1149 
1150 .code32  
1151 start32:
1152   
1153   movw    $(SEG_KDATA<<3), %ax    
1154   movw    %ax, %ds                
1155   movw    %ax, %es                
1156   movw    %ax, %ss                
1157   movw    $0, %ax                 
1158   movw    %ax, %fs                
1159   movw    %ax, %gs                
1160 
1161   
1162   movl    %cr4, %eax
1163   orl     $(CR4_PSE), %eax
1164   movl    %eax, %cr4
1165   
1166   movl    (start-12), %eax
1167   movl    %eax, %cr3
1168   
1169   movl    %cr0, %eax
1170   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1171   movl    %eax, %cr0
1172 
1173   
1174   movl    (start-4), %esp
1175   
1176   call	 *(start-8)
1177 
1178   movw    $0x8a00, %ax
1179   movw    %ax, %dx
1180   outw    %ax, %dx
1181   movw    $0x8ae0, %ax
1182   outw    %ax, %dx
1183 spin:
1184   jmp     spin
1185 
1186 .p2align 2
1187 gdt:
1188   SEG_NULLASM
1189   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1190   SEG_ASM(STA_W, 0, 0xffffffff)
1191 
1192 
1193 gdtdesc:
1194   .word   (gdtdesc - gdt - 1)
1195   .long   gdt
1196 
1197 
1198 
1199 
1200 #include "types.h"
1201 #include "defs.h"
1202 #include "param.h"
1203 #include "memlayout.h"
1204 #include "mmu.h"
1205 #include "proc.h"
1206 #include "x86.h"
1207 
1208 static void startothers(void);
1209 static void mpmain(void)  __attribute__((noreturn));
1210 extern pde_t *kpgdir;
1211 extern char end[]; 
1212 
1213 
1214 
1215 
1216 int
1217 main(void)
1218 {
1219   kinit1(end, P2V(4*1024*1024)); 
1220   kvmalloc();      
1221   mpinit();        
1222   lapicinit();     
1223   seginit();       
1224   picinit();       
1225   ioapicinit();    
1226   consoleinit();   
1227   uartinit();      
1228   pinit();         
1229   tvinit();        
1230   binit();         
1231   fileinit();      
1232   ideinit();       
1233   startothers();   
1234   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1235   userinit();      
1236   mpmain();        
1237 }
1238 
1239 
1240 static void
1241 mpenter(void)
1242 {
1243   switchkvm();
1244   seginit();
1245   lapicinit();
1246   mpmain();
1247 }
1248 
1249 
1250 
1251 static void
1252 mpmain(void)
1253 {
1254   cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
1255   idtinit();       
1256   xchg(&(mycpu()->started), 1); 
1257   scheduler();     
1258 }
1259 
1260 pde_t entrypgdir[];  
1261 
1262 
1263 static void
1264 startothers(void)
1265 {
1266   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1267   uchar *code;
1268   struct cpu *c;
1269   char *stack;
1270 
1271   
1272   
1273   
1274   code = P2V(0x7000);
1275   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1276 
1277   for(c = cpus; c < cpus+ncpu; c++){
1278     if(c == mycpu())  
1279       continue;
1280 
1281     
1282     
1283     
1284     stack = kalloc();
1285     *(void**)(code-4) = stack + KSTACKSIZE;
1286     *(void(**)(void))(code-8) = mpenter;
1287     *(int**)(code-12) = (void *) V2P(entrypgdir);
1288 
1289     lapicstartap(c->apicid, V2P(code));
1290 
1291     
1292     while(c->started == 0)
1293       ;
1294   }
1295 }
1296 
1297 
1298 
1299 
1300 
1301 
1302 
1303 
1304 
1305 __attribute__((__aligned__(PGSIZE)))
1306 pde_t entrypgdir[NPDENTRIES] = {
1307   
1308   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1309   
1310   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1311 };
1312 
1313 
1314 
1315 
1316 
1317 
1318 
1319 
1320 
1321 
1322 
1323 
1324 
1325 
1326 
1327 
1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 
1338 
1339 
1340 
1341 
1342 
1343 
1344 
1345 
1346 
1347 
1348 
1349 
1350 
1351 
1352 
1353 
1354 
1355 
1356 
1357 
1358 
1359 
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 
1403 
1404 
1405 
1406 
1407 
1408 
1409 
1410 
1411 
1412 
1413 
1414 
1415 
1416 
1417 
1418 
1419 
1420 
1421 
1422 
1423 
1424 
1425 
1426 
1427 
1428 
1429 
1430 
1431 
1432 
1433 
1434 
1435 
1436 
1437 
1438 
1439 
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 
1452 
1453 
1454 
1455 
1456 
1457 
1458 
1459 
1460 
1461 
1462 
1463 
1464 
1465 
1466 
1467 
1468 
1469 
1470 
1471 
1472 
1473 
1474 
1475 
1476 
1477 
1478 
1479 
1480 
1481 
1482 
1483 
1484 
1485 
1486 
1487 
1488 
1489 
1490 
1491 
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 struct spinlock {
1502   uint locked;       
1503 
1504   
1505   char *name;        
1506   struct cpu *cpu;   
1507   uint pcs[10];      
1508                      
1509 };
1510 
1511 
1512 
1513 
1514 
1515 
1516 
1517 
1518 
1519 
1520 
1521 
1522 
1523 
1524 
1525 
1526 
1527 
1528 
1529 
1530 
1531 
1532 
1533 
1534 
1535 
1536 
1537 
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 
1551 
1552 #include "types.h"
1553 #include "defs.h"
1554 #include "param.h"
1555 #include "x86.h"
1556 #include "memlayout.h"
1557 #include "mmu.h"
1558 #include "proc.h"
1559 #include "spinlock.h"
1560 
1561 void
1562 initlock(struct spinlock *lk, char *name)
1563 {
1564   lk->name = name;
1565   lk->locked = 0;
1566   lk->cpu = 0;
1567 }
1568 
1569 
1570 
1571 
1572 
1573 void
1574 acquire(struct spinlock *lk)
1575 {
1576   pushcli(); 
1577   if(holding(lk))
1578     panic("acquire");
1579 
1580   
1581   while(xchg(&lk->locked, 1) != 0)
1582     ;
1583 
1584   
1585   
1586   
1587   __sync_synchronize();
1588 
1589   
1590   lk->cpu = mycpu();
1591   getcallerpcs(&lk, lk->pcs);
1592 }
1593 
1594 
1595 
1596 
1597 
1598 
1599 
1600 
1601 void
1602 release(struct spinlock *lk)
1603 {
1604   if(!holding(lk))
1605     panic("release");
1606 
1607   lk->pcs[0] = 0;
1608   lk->cpu = 0;
1609 
1610   
1611   
1612   
1613   
1614   
1615   __sync_synchronize();
1616 
1617   
1618   
1619   
1620   asm volatile("movl $0, %0" : "+m" (lk->locked) : );
1621 
1622   popcli();
1623 }
1624 
1625 
1626 void
1627 getcallerpcs(void *v, uint pcs[])
1628 {
1629   uint *ebp;
1630   int i;
1631 
1632   ebp = (uint*)v - 2;
1633   for(i = 0; i < 10; i++){
1634     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1635       break;
1636     pcs[i] = ebp[1];     
1637     ebp = (uint*)ebp[0]; 
1638   }
1639   for(; i < 10; i++)
1640     pcs[i] = 0;
1641 }
1642 
1643 
1644 
1645 
1646 
1647 
1648 
1649 
1650 
1651 int
1652 holding(struct spinlock *lock)
1653 {
1654   int r;
1655   pushcli();
1656   r = lock->locked && lock->cpu == mycpu();
1657   popcli();
1658   return r;
1659 }
1660 
1661 
1662 
1663 
1664 
1665 
1666 void
1667 pushcli(void)
1668 {
1669   int eflags;
1670 
1671   eflags = readeflags();
1672   cli();
1673   if(mycpu()->ncli == 0)
1674     mycpu()->intena = eflags & FL_IF;
1675   mycpu()->ncli += 1;
1676 }
1677 
1678 void
1679 popcli(void)
1680 {
1681   if(readeflags()&FL_IF)
1682     panic("popcli - interruptible");
1683   if(--mycpu()->ncli < 0)
1684     panic("popcli");
1685   if(mycpu()->ncli == 0 && mycpu()->intena)
1686     sti();
1687 }
1688 
1689 
1690 
1691 
1692 
1693 
1694 
1695 
1696 
1697 
1698 
1699 
1700 #include "param.h"
1701 #include "types.h"
1702 #include "defs.h"
1703 #include "x86.h"
1704 #include "memlayout.h"
1705 #include "mmu.h"
1706 #include "proc.h"
1707 #include "elf.h"
1708 
1709 extern char data[];  
1710 pde_t *kpgdir;  
1711 
1712 
1713 
1714 void
1715 seginit(void)
1716 {
1717   struct cpu *c;
1718 
1719   
1720   
1721   
1722   
1723   c = &cpus[cpuid()];
1724   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1725   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1726   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1727   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1728   lgdt(c->gdt, sizeof(c->gdt));
1729 }
1730 
1731 
1732 
1733 
1734 static pte_t *
1735 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1736 {
1737   pde_t *pde;
1738   pte_t *pgtab;
1739 
1740   pde = &pgdir[PDX(va)];
1741   if(*pde & PTE_P){
1742     pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
1743   } else {
1744     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1745       return 0;
1746     
1747     memset(pgtab, 0, PGSIZE);
1748     
1749     
1750     
1751     *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
1752   }
1753   return &pgtab[PTX(va)];
1754 }
1755 
1756 
1757 
1758 
1759 static int
1760 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1761 {
1762   char *a, *last;
1763   pte_t *pte;
1764 
1765   a = (char*)PGROUNDDOWN((uint)va);
1766   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1767   for(;;){
1768     if((pte = walkpgdir(pgdir, a, 1)) == 0)
1769       return -1;
1770     if(*pte & PTE_P)
1771       panic("remap");
1772     *pte = pa | perm | PTE_P;
1773     if(a == last)
1774       break;
1775     a += PGSIZE;
1776     pa += PGSIZE;
1777   }
1778   return 0;
1779 }
1780 
1781 
1782 
1783 
1784 
1785 
1786 
1787 
1788 
1789 
1790 
1791 
1792 
1793 
1794 
1795 
1796 
1797 
1798 
1799 
1800 
1801 
1802 
1803 
1804 static struct kmap {
1805   void *virt;
1806   uint phys_start;
1807   uint phys_end;
1808   int perm;
1809 } kmap[] = {
1810  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1811  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1812  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1813  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, 
1814 };
1815 
1816 
1817 pde_t*
1818 setupkvm(void)
1819 {
1820   pde_t *pgdir;
1821   struct kmap *k;
1822 
1823   if((pgdir = (pde_t*)kalloc()) == 0)
1824     return 0;
1825   memset(pgdir, 0, PGSIZE);
1826   if (P2V(PHYSTOP) > (void*)DEVSPACE)
1827     panic("PHYSTOP too high");
1828   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1829     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1830                 (uint)k->phys_start, k->perm) < 0) {
1831       freevm(pgdir);
1832       return 0;
1833     }
1834   return pgdir;
1835 }
1836 
1837 
1838 
1839 void
1840 kvmalloc(void)
1841 {
1842   kpgdir = setupkvm();
1843   switchkvm();
1844 }
1845 
1846 
1847 
1848 
1849 
1850 
1851 
1852 void
1853 switchkvm(void)
1854 {
1855   lcr3(V2P(kpgdir));   
1856 }
1857 
1858 
1859 void
1860 switchuvm(struct proc *p)
1861 {
1862   if(p == 0)
1863     panic("switchuvm: no process");
1864   if(p->kstack == 0)
1865     panic("switchuvm: no kstack");
1866   if(p->pgdir == 0)
1867     panic("switchuvm: no pgdir");
1868 
1869   pushcli();
1870   mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
1871                                 sizeof(mycpu()->ts)-1, 0);
1872   mycpu()->gdt[SEG_TSS].s = 0;
1873   mycpu()->ts.ss0 = SEG_KDATA << 3;
1874   mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
1875   
1876   
1877   mycpu()->ts.iomb = (ushort) 0xFFFF;
1878   ltr(SEG_TSS << 3);
1879   lcr3(V2P(p->pgdir));  
1880   popcli();
1881 }
1882 
1883 
1884 
1885 void
1886 inituvm(pde_t *pgdir, char *init, uint sz)
1887 {
1888   char *mem;
1889 
1890   if(sz >= PGSIZE)
1891     panic("inituvm: more than a page");
1892   mem = kalloc();
1893   memset(mem, 0, PGSIZE);
1894   mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
1895   memmove(mem, init, sz);
1896 }
1897 
1898 
1899 
1900 
1901 
1902 int
1903 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1904 {
1905   uint i, pa, n;
1906   pte_t *pte;
1907 
1908   if((uint) addr % PGSIZE != 0)
1909     panic("loaduvm: addr must be page aligned");
1910   for(i = 0; i < sz; i += PGSIZE){
1911     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1912       panic("loaduvm: address should exist");
1913     pa = PTE_ADDR(*pte);
1914     if(sz - i < PGSIZE)
1915       n = sz - i;
1916     else
1917       n = PGSIZE;
1918     if(readi(ip, P2V(pa), offset+i, n) != n)
1919       return -1;
1920   }
1921   return 0;
1922 }
1923 
1924 
1925 
1926 int
1927 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1928 {
1929   char *mem;
1930   uint a;
1931 
1932   if(newsz >= KERNBASE)
1933     return 0;
1934   if(newsz < oldsz)
1935     return oldsz;
1936 
1937   a = PGROUNDUP(oldsz);
1938   for(; a < newsz; a += PGSIZE){
1939     mem = kalloc();
1940     if(mem == 0){
1941       cprintf("allocuvm out of memory\n");
1942       deallocuvm(pgdir, newsz, oldsz);
1943       return 0;
1944     }
1945     memset(mem, 0, PGSIZE);
1946     if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
1947       cprintf("allocuvm out of memory (2)\n");
1948       deallocuvm(pgdir, newsz, oldsz);
1949       kfree(mem);
1950       return 0;
1951     }
1952   }
1953   return newsz;
1954 }
1955 
1956 
1957 
1958 
1959 
1960 int
1961 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1962 {
1963   pte_t *pte;
1964   uint a, pa;
1965 
1966   if(newsz >= oldsz)
1967     return oldsz;
1968 
1969   a = PGROUNDUP(newsz);
1970   for(; a  < oldsz; a += PGSIZE){
1971     pte = walkpgdir(pgdir, (char*)a, 0);
1972     if(!pte)
1973       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
1974     else if((*pte & PTE_P) != 0){
1975       pa = PTE_ADDR(*pte);
1976       if(pa == 0)
1977         panic("kfree");
1978       char *v = P2V(pa);
1979       kfree(v);
1980       *pte = 0;
1981     }
1982   }
1983   return newsz;
1984 }
1985 
1986 
1987 
1988 
1989 
1990 
1991 
1992 
1993 
1994 
1995 
1996 
1997 
1998 
1999 
2000 
2001 
2002 void
2003 freevm(pde_t *pgdir)
2004 {
2005   uint i;
2006 
2007   if(pgdir == 0)
2008     panic("freevm: no pgdir");
2009   deallocuvm(pgdir, KERNBASE, 0);
2010   for(i = 0; i < NPDENTRIES; i++){
2011     if(pgdir[i] & PTE_P){
2012       char * v = P2V(PTE_ADDR(pgdir[i]));
2013       kfree(v);
2014     }
2015   }
2016   kfree((char*)pgdir);
2017 }
2018 
2019 
2020 
2021 void
2022 clearpteu(pde_t *pgdir, char *uva)
2023 {
2024   pte_t *pte;
2025 
2026   pte = walkpgdir(pgdir, uva, 0);
2027   if(pte == 0)
2028     panic("clearpteu");
2029   *pte &= ~PTE_U;
2030 }
2031 
2032 
2033 
2034 pde_t*
2035 copyuvm(pde_t *pgdir, uint sz)
2036 {
2037   pde_t *d;
2038   pte_t *pte;
2039   uint pa, i, flags;
2040   char *mem;
2041 
2042   if((d = setupkvm()) == 0)
2043     return 0;
2044   for(i = 0; i < sz; i += PGSIZE){
2045     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
2046       panic("copyuvm: pte should exist");
2047     if(!(*pte & PTE_P))
2048       panic("copyuvm: page not present");
2049     pa = PTE_ADDR(*pte);
2050     flags = PTE_FLAGS(*pte);
2051     if((mem = kalloc()) == 0)
2052       goto bad;
2053     memmove(mem, (char*)P2V(pa), PGSIZE);
2054     if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
2055       kfree(mem);
2056       goto bad;
2057     }
2058   }
2059   return d;
2060 
2061 bad:
2062   freevm(d);
2063   return 0;
2064 }
2065 
2066 
2067 
2068 
2069 
2070 
2071 
2072 
2073 
2074 
2075 
2076 
2077 
2078 
2079 
2080 
2081 
2082 
2083 
2084 
2085 
2086 
2087 
2088 
2089 
2090 
2091 
2092 
2093 
2094 
2095 
2096 
2097 
2098 
2099 
2100 
2101 char*
2102 uva2ka(pde_t *pgdir, char *uva)
2103 {
2104   pte_t *pte;
2105 
2106   pte = walkpgdir(pgdir, uva, 0);
2107   if((*pte & PTE_P) == 0)
2108     return 0;
2109   if((*pte & PTE_U) == 0)
2110     return 0;
2111   return (char*)P2V(PTE_ADDR(*pte));
2112 }
2113 
2114 
2115 
2116 
2117 int
2118 copyout(pde_t *pgdir, uint va, void *p, uint len)
2119 {
2120   char *buf, *pa0;
2121   uint n, va0;
2122 
2123   buf = (char*)p;
2124   while(len > 0){
2125     va0 = (uint)PGROUNDDOWN(va);
2126     pa0 = uva2ka(pgdir, (char*)va0);
2127     if(pa0 == 0)
2128       return -1;
2129     n = PGSIZE - (va - va0);
2130     if(n > len)
2131       n = len;
2132     memmove(pa0 + (va - va0), buf, n);
2133     len -= n;
2134     buf += n;
2135     va = va0 + PGSIZE;
2136   }
2137   return 0;
2138 }
2139 
2140 
2141 
2142 
2143 
2144 
2145 
2146 
2147 
2148 
2149 
2150 
2151 
2152 
2153 
2154 
2155 
2156 
2157 
2158 
2159 
2160 
2161 
2162 
2163 
2164 
2165 
2166 
2167 
2168 
2169 
2170 
2171 
2172 
2173 
2174 
2175 
2176 
2177 
2178 
2179 
2180 
2181 
2182 
2183 
2184 
2185 
2186 
2187 
2188 
2189 
2190 
2191 
2192 
2193 
2194 
2195 
2196 
2197 
2198 
2199 
2200 
2201 
2202 
2203 
2204 
2205 
2206 
2207 
2208 
2209 
2210 
2211 
2212 
2213 
2214 
2215 
2216 
2217 
2218 
2219 
2220 
2221 
2222 
2223 
2224 
2225 
2226 
2227 
2228 
2229 
2230 
2231 
2232 
2233 
2234 
2235 
2236 
2237 
2238 
2239 
2240 
2241 
2242 
2243 
2244 
2245 
2246 
2247 
2248 
2249 
2250 
2251 
2252 
2253 
2254 
2255 
2256 
2257 
2258 
2259 
2260 
2261 
2262 
2263 
2264 
2265 
2266 
2267 
2268 
2269 
2270 
2271 
2272 
2273 
2274 
2275 
2276 
2277 
2278 
2279 
2280 
2281 
2282 
2283 
2284 
2285 
2286 
2287 
2288 
2289 
2290 
2291 
2292 
2293 
2294 
2295 
2296 
2297 
2298 
2299 
2300 
2301 struct cpu {
2302   uchar apicid;                
2303   struct context *scheduler;   
2304   struct taskstate ts;         
2305   struct segdesc gdt[NSEGS];   
2306   volatile uint started;       
2307   int ncli;                    
2308   int intena;                  
2309   struct proc *proc;           
2310 };
2311 
2312 extern struct cpu cpus[NCPU];
2313 extern int ncpu;
2314 
2315 
2316 
2317 
2318 
2319 
2320 
2321 
2322 
2323 
2324 
2325 
2326 struct context {
2327   uint edi;
2328   uint esi;
2329   uint ebx;
2330   uint ebp;
2331   uint eip;
2332 };
2333 
2334 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2335 
2336 
2337 struct proc {
2338   uint sz;                     
2339   pde_t* pgdir;                
2340   char *kstack;                
2341   enum procstate state;        
2342   int pid;                     
2343   int nice;                    
2344   struct proc *parent;         
2345   struct trapframe *tf;        
2346   struct context *context;     
2347   void *chan;                  
2348   int killed;                  
2349   struct file *ofile[NOFILE];  
2350   struct inode *cwd;           
2351   char name[16];               
2352   void* stack;
2353   int tid;
2354   int tcnt;
2355 };
2356 
2357 
2358 
2359 
2360 
2361 
2362 
2363 
2364 
2365 
2366 
2367 
2368 
2369 
2370 
2371 
2372 
2373 
2374 
2375 
2376 
2377 
2378 
2379 
2380 
2381 
2382 
2383 
2384 
2385 
2386 
2387 
2388 
2389 
2390 
2391 
2392 
2393 
2394 
2395 
2396 
2397 
2398 
2399 
2400 #include "types.h"
2401 #include "defs.h"
2402 #include "param.h"
2403 #include "memlayout.h"
2404 #include "mmu.h"
2405 #include "x86.h"
2406 #include "proc.h"
2407 #include "spinlock.h"
2408 #include "stat.h"
2409 #include "fcntl.h"
2410 
2411 struct {
2412   struct spinlock lock;
2413   struct proc proc[NPROC];
2414 } ptable;
2415 
2416 static struct proc *initproc;
2417 
2418 int nextpid = 1;
2419 extern void forkret(void);
2420 extern void trapret(void);
2421 
2422 static void wakeup1(void *chan);
2423 
2424   void
2425 pinit(void)
2426 {
2427   initlock(&ptable.lock, "ptable");
2428 }
2429 
2430 
2431 int
2432 cpuid() {
2433   return mycpu()-cpus;
2434 }
2435 
2436 
2437 
2438 
2439 
2440 
2441 
2442 
2443 
2444 
2445 
2446 
2447 
2448 
2449 
2450 
2451 
2452   struct cpu*
2453 mycpu(void)
2454 {
2455   int apicid, i;
2456 
2457   if(readeflags()&FL_IF)
2458     panic("mycpu called with interrupts enabled\n");
2459 
2460   apicid = lapicid();
2461   
2462   
2463   for (i = 0; i < ncpu; ++i) {
2464     if (cpus[i].apicid == apicid)
2465       return &cpus[i];
2466   }
2467   panic("unknown apicid\n");
2468 }
2469 
2470 
2471 
2472 struct proc*
2473 myproc(void) {
2474   struct cpu *c;
2475   struct proc *p;
2476   pushcli();
2477   c = mycpu();
2478   p = c->proc;
2479   popcli();
2480   return p;
2481 }
2482 
2483 
2484 
2485 
2486 
2487 
2488 
2489 
2490 
2491 
2492 
2493 
2494 
2495 
2496 
2497 
2498 
2499 
2500 
2501 
2502 
2503 
2504   static struct proc*
2505 allocproc(void)
2506 {
2507   struct proc *p;
2508   char *sp;
2509 
2510   acquire(&ptable.lock);
2511 
2512   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2513     if(p->state == UNUSED)
2514       goto found;
2515 
2516   release(&ptable.lock);
2517   return 0;
2518 
2519 found:
2520   p->state = EMBRYO;
2521   p->pid = nextpid++;
2522 
2523 
2524   release(&ptable.lock);
2525 
2526   
2527   if((p->kstack = kalloc()) == 0){
2528     p->state = UNUSED;
2529     return 0;
2530   }
2531   sp = p->kstack + KSTACKSIZE;
2532 
2533   
2534   sp -= sizeof *p->tf;
2535   p->tf = (struct trapframe*)sp;
2536 
2537   
2538   
2539   sp -= 4;
2540   *(uint*)sp = (uint)trapret;
2541 
2542   sp -= sizeof *p->context;
2543   p->context = (struct context*)sp;
2544   memset(p->context, 0, sizeof *p->context);
2545   p->context->eip = (uint)forkret;
2546   p->tcnt = 0;
2547   return p;
2548 }
2549 
2550 
2551 
2552   void
2553 userinit(void)
2554 {
2555   struct proc *p;
2556   extern char _binary_initcode_start[], _binary_initcode_size[];
2557 
2558   p = allocproc();
2559 
2560   p->tid = 0;
2561   initproc = p;
2562   if((p->pgdir = setupkvm()) == 0)
2563     panic("userinit: out of memory?");
2564   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2565   p->sz = PGSIZE;
2566   memset(p->tf, 0, sizeof(*p->tf));
2567   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2568   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2569   p->tf->es = p->tf->ds;
2570   p->tf->ss = p->tf->ds;
2571   p->tf->eflags = FL_IF;
2572   p->tf->esp = PGSIZE;
2573   p->tf->eip = 0;  
2574 
2575   safestrcpy(p->name, "initcode", sizeof(p->name));
2576   p->cwd = namei("/");
2577 
2578   
2579   
2580   
2581   
2582   acquire(&ptable.lock);
2583 
2584   p->state = RUNNABLE;
2585   p->nice = 20;
2586   p->tid = 0;
2587   p->tcnt = 0;
2588   release(&ptable.lock);
2589 }
2590 
2591 
2592 
2593 
2594 
2595 
2596 
2597 
2598 
2599 
2600 
2601 
2602   int
2603 growproc(int n)
2604 {
2605   uint sz;
2606   struct proc *curproc = myproc();
2607 
2608   sz = curproc->sz;
2609   if(n > 0){
2610     if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
2611       return -1;
2612   } else if(n < 0){
2613     if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
2614       return -1;
2615   }
2616   curproc->sz = sz;
2617   switchuvm(curproc);
2618   return 0;
2619 }
2620 
2621 
2622 
2623 
2624   int
2625 fork(void)
2626 {
2627   int i, pid;
2628   struct proc *np;
2629   struct proc *curproc = myproc();
2630   
2631   if((np = allocproc()) == 0){
2632     return -1;
2633   }
2634 
2635   
2636   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
2637     kfree(np->kstack);
2638     np->kstack = 0;
2639     np->state = UNUSED;
2640     return -1;
2641   }
2642   np->sz = curproc->sz;
2643   np->parent = curproc;
2644   *np->tf = *curproc->tf;
2645   np->nice = 20;
2646   
2647   np->tf->eax = 0;
2648   np->tid = 0;
2649   np->tcnt = 0;
2650   for(i = 0; i < NOFILE; i++)
2651     if(curproc->ofile[i])
2652       np->ofile[i] = filedup(curproc->ofile[i]);
2653   np->cwd = idup(curproc->cwd);
2654   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
2655 
2656   pid = np->pid;
2657 
2658   acquire(&ptable.lock);
2659 
2660   np->state = RUNNABLE;
2661   release(&ptable.lock);
2662 
2663   return pid;
2664 }
2665 
2666 
2667 
2668 
2669   void
2670 exit(void)
2671 {
2672   struct proc *curproc = myproc();
2673   struct proc *p;
2674   int fd;
2675 
2676   if(curproc == initproc)
2677     panic("init exiting");
2678 
2679   
2680   for(fd = 0; fd < NOFILE; fd++){
2681     if(curproc->ofile[fd]){
2682       fileclose(curproc->ofile[fd]);
2683       curproc->ofile[fd] = 0;
2684     }
2685   }
2686 
2687   begin_op();
2688   iput(curproc->cwd);
2689   end_op();
2690   curproc->cwd = 0;
2691 
2692   acquire(&ptable.lock);
2693 
2694   
2695   wakeup1(curproc->parent);
2696 
2697 
2698 
2699 
2700   
2701   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2702     if(p->parent == curproc){
2703       p->parent = initproc;
2704       if(p->state == ZOMBIE)
2705         wakeup1(initproc);
2706     }
2707   }
2708   /*
2709      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2710      if(p->pid == curproc->pid){
2711      for(fd = 0; fd<NOFILE; fd++){
2712      if(p->ofile[fd]){
2713      fileclose(p->ofile[fd]);
2714      p->ofile[fd] = 0;
2715      }
2716      }
2717      begin_op();
2718      iput(p->cwd);
2719      end_op();
2720      p->pwd = 0;
2721      p->state = ZOMBIE;
2722      }
2723      }*/
2724   
2725   curproc->state = ZOMBIE;
2726   sched();
2727   panic("zombie exit");
2728   if(curproc->tid == 1){
2729     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2730       if(p->pid == curproc->pid){
2731         for(fd = 0; fd<NOFILE; fd++){
2732           if(p->ofile[fd]){
2733             fileclose(p->ofile[fd]);
2734             p->ofile[fd] = 0;
2735           }
2736         }
2737         begin_op();
2738         iput(p->cwd);
2739         end_op();
2740         p->cwd = 0;
2741         p->state = ZOMBIE;
2742       }
2743     }
2744 
2745   }
2746 
2747 }
2748 
2749 
2750 
2751 
2752   int
2753 wait(void)
2754 {
2755   struct proc *p;
2756   int havekids, pid;
2757   struct proc *curproc = myproc();
2758 
2759   acquire(&ptable.lock);
2760   for(;;){
2761     
2762     havekids = 0;
2763     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2764       if(p->parent != curproc)
2765         continue;
2766       havekids = 1;
2767       if(p->state == ZOMBIE){
2768         
2769         pid = p->pid;
2770         kfree(p->kstack);
2771         p->kstack = 0;
2772         freevm(p->pgdir);
2773         p->pid = 0;
2774         p->parent = 0;
2775         p->name[0] = 0;
2776         p->killed = 0;
2777         p->state = UNUSED;
2778         release(&ptable.lock);
2779         return pid;
2780       }
2781     }
2782 
2783     
2784     if(!havekids || curproc->killed){
2785       release(&ptable.lock);
2786       return -1;
2787     }
2788 
2789     
2790     sleep(curproc, &ptable.lock);  
2791   }
2792 }
2793 
2794 
2795 
2796 
2797 
2798 
2799 
2800 
2801 
2802 
2803 
2804 
2805 
2806 
2807   void
2808 scheduler(void)
2809 {
2810   struct proc *p;
2811   struct cpu *c = mycpu();
2812   c->proc = 0;
2813 
2814   for(;;){
2815     
2816     sti();
2817 
2818     
2819     acquire(&ptable.lock);
2820     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2821       if(p->state != RUNNABLE)
2822         continue;
2823 
2824       
2825       
2826       
2827       c->proc = p;
2828       switchuvm(p);
2829       p->state = RUNNING;
2830 
2831       swtch(&(c->scheduler), p->context);
2832       switchkvm();
2833 
2834       
2835       
2836       c->proc = 0;
2837     }
2838     release(&ptable.lock);
2839 
2840   }
2841 }
2842 
2843 
2844 
2845 
2846 
2847 
2848 
2849 
2850 
2851 
2852 
2853 
2854 
2855 
2856 
2857   void
2858 sched(void)
2859 {
2860   int intena;
2861   struct proc *p = myproc();
2862 
2863   if(!holding(&ptable.lock))
2864     panic("sched ptable.lock");
2865   if(mycpu()->ncli != 1)
2866     panic("sched locks");
2867   if(p->state == RUNNING)
2868     panic("sched running");
2869   if(readeflags()&FL_IF)
2870     panic("sched interruptible");
2871   intena = mycpu()->intena;
2872   swtch(&p->context, mycpu()->scheduler);
2873   mycpu()->intena = intena;
2874 }
2875 
2876 
2877   void
2878 yield(void)
2879 {
2880   acquire(&ptable.lock);  
2881   myproc()->state = RUNNABLE;
2882   sched();
2883   release(&ptable.lock);
2884 }
2885 
2886 
2887 
2888 
2889 
2890 
2891 
2892 
2893 
2894 
2895 
2896 
2897 
2898 
2899 
2900 
2901 
2902   void
2903 forkret(void)
2904 {
2905   static int first = 1;
2906   
2907   release(&ptable.lock);
2908 
2909   if (first) {
2910     
2911     
2912     
2913     first = 0;
2914     iinit(ROOTDEV);
2915     initlog(ROOTDEV);
2916   }
2917 
2918   
2919 }
2920 
2921 
2922 
2923   void
2924 sleep(void *chan, struct spinlock *lk)
2925 {
2926   struct proc *p = myproc();
2927 
2928   if(p == 0)
2929     panic("sleep");
2930 
2931   if(lk == 0)
2932     panic("sleep without lk");
2933 
2934   
2935   
2936   
2937   
2938   
2939   
2940   if(lk != &ptable.lock){  
2941     acquire(&ptable.lock);  
2942     release(lk);
2943   }
2944   
2945   p->chan = chan;
2946   p->state = SLEEPING;
2947 
2948   sched();
2949 
2950   
2951   p->chan = 0;
2952 
2953   
2954   if(lk != &ptable.lock){  
2955     release(&ptable.lock);
2956     acquire(lk);
2957   }
2958 }
2959 
2960 
2961 
2962 
2963 
2964 
2965 
2966 
2967 
2968 
2969 
2970 
2971 
2972 
2973 
2974 
2975 
2976 
2977 
2978 
2979 
2980 
2981 
2982 
2983 
2984 
2985 
2986 
2987 
2988 
2989 
2990 
2991 
2992 
2993 
2994 
2995 
2996 
2997 
2998 
2999 
3000 
3001 
3002   static void
3003 wakeup1(void *chan)
3004 {
3005   struct proc *p;
3006 
3007   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
3008     if(p->state == SLEEPING && p->chan == chan)
3009       p->state = RUNNABLE;
3010 }
3011 
3012 
3013   void
3014 wakeup(void *chan)
3015 {
3016   acquire(&ptable.lock);
3017   wakeup1(chan);
3018   release(&ptable.lock);
3019 }
3020 
3021 
3022 
3023 
3024   int
3025 kill(int pid)
3026 {
3027   struct proc *p;
3028 
3029   acquire(&ptable.lock);
3030   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3031     if(p->pid == pid){
3032       p->killed = 1;
3033       
3034       if(p->state == SLEEPING)
3035         p->state = RUNNABLE;
3036       release(&ptable.lock);
3037       return 0;
3038     }
3039   }
3040   release(&ptable.lock);
3041   return -1;
3042 }
3043 
3044 
3045 
3046 
3047 
3048 
3049 
3050 
3051 
3052 
3053   void
3054 procdump(void)
3055 {
3056   static char *states[] = {
3057     [UNUSED]    "unused",
3058     [EMBRYO]    "embryo",
3059     [SLEEPING]  "sleep ",
3060     [RUNNABLE]  "runble",
3061     [RUNNING]   "run   ",
3062     [ZOMBIE]    "zombie"
3063   };
3064   int i;
3065   struct proc *p;
3066   char *state;
3067   uint pc[10];
3068 
3069   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3070     if(p->state == UNUSED)
3071       continue;
3072     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
3073       state = states[p->state];
3074     else
3075       state = "???";
3076     cprintf("%d %s %s", p->pid, state, p->name);
3077     if(p->state == SLEEPING){
3078       getcallerpcs((uint*)p->context->ebp+2, pc);
3079       for(i=0; i<10 && pc[i] != 0; i++)
3080         cprintf(" %p", pc[i]);
3081     }
3082     cprintf("\n");
3083   }
3084 }
3085 
3086 
3087 
3088 
3089 
3090 
3091 
3092 
3093 
3094 
3095 
3096 
3097 
3098 
3099 
3100   int
3101 getnice(int pid)
3102 {
3103   struct proc* p;
3104 
3105   acquire(&ptable.lock);
3106   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3107     if(p->pid == pid){
3108       release(&ptable.lock);
3109       cprintf("pid %d's nice value: %d\n", p->pid, p->nice);
3110       return p->nice;
3111     }
3112   }
3113   release(&ptable.lock);
3114   cprintf("pid %d not exists\n", p->pid);
3115   return -1;
3116 }
3117 
3118   int
3119 setnice(int pid, int value)
3120 {
3121   struct proc* p;
3122   if(!(0<= value && value<=39)){
3123     return -1;
3124   }
3125   acquire(&ptable.lock);
3126   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3127     if(p->pid == pid){
3128       p->nice = value;
3129       cprintf("pid %d's nice value has set as %d\n", p->pid, p->nice);
3130       release(&ptable.lock);
3131       return 0;
3132     }
3133   }
3134   release(&ptable.lock);
3135   cprintf("pid %d not exists\n", p->pid);
3136   return -1;
3137 }
3138 
3139 
3140 
3141 
3142 
3143 
3144 
3145 
3146 
3147 
3148 
3149 
3150 char* print_enum(enum procstate a)
3151 {
3152   if(a == RUNNING){
3153     return "RUNNING\t";
3154   }
3155   else if(a == SLEEPING){
3156     return "SLEEPING";
3157   }
3158   else if(a == EMBRYO){
3159     return "EMBRYO\t";
3160   }
3161   else if(a == UNUSED){
3162     return "UNUSED\t";
3163   }
3164   else if(a == RUNNABLE){
3165     return "RUNNABLE";
3166   }
3167   else{
3168     return "ZOMBIE\t";
3169   }
3170 }
3171 
3172   void
3173 ps(int pid)
3174 {
3175   struct proc* p;
3176 
3177   acquire(&ptable.lock);
3178   if(pid == 0) {
3179     for(p = ptable.proc; p<&ptable.proc[NPROC]; p++){
3180       if(p->pid != 0)
3181         cprintf("pid: %d\tnice: %d\tstatus: %s\tname: %s\n", p->pid, p->nice, print_enum(p->state), p->name);
3182     }
3183   }
3184   else{
3185     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3186       if(p->pid == pid){
3187         cprintf("pid: %d\tnice: %d\tstatus: %s\tname: %s\n", p->pid, p->nice, print_enum(p->state), p->name);
3188         break;
3189       }
3190     }
3191   }
3192   release(&ptable.lock);
3193 }
3194 
3195 
3196 
3197 
3198 
3199 
3200 int thread_create(void* (*function)(void*), void* arg, void* stack)
3201 {
3202   int i;
3203   struct proc *np;
3204   struct proc *curproc = myproc();
3205   
3206   
3207   if(curproc->tcnt == 8){
3208     cprintf("cannot alloate more threads(maxmium 8)\n");
3209     return -1;
3210   }
3211   
3212   if((np = allocproc()) == 0){
3213     cprintf("allocproc error\n");
3214     return -1;
3215   }
3216 
3217   
3218   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
3219     cprintf("copy process state error\n");
3220     kfree(np->kstack);
3221     np->kstack = 0;
3222     np->state = UNUSED;
3223     return -1;
3224   }
3225 
3226   np->pid = curproc->pid;
3227   np->sz = curproc->sz;
3228   np->parent = curproc;
3229   *np->tf = *curproc->tf;
3230   np->nice = 20;
3231   np->tcnt = curproc->tcnt;
3232   np->tcnt += 1;
3233   curproc->tcnt += 1;
3234   np->tid = np->tcnt;
3235   np->tf->eip = (uint)function;
3236 
3237   np->stack = stack;
3238   np->tf->ebp = (uint)stack + PGSIZE;
3239   np->tf->esp = (uint)stack + PGSIZE;
3240   np->tf->esp -= 4;
3241   
3242   *((uint*)np->tf->esp) = (uint)arg;
3243 
3244   
3245   np->tf->eax = 0;
3246   for(i = 0; i < NOFILE; i++)
3247     if(curproc->ofile[i])
3248       np->ofile[i] = filedup(curproc->ofile[i]);
3249   np->cwd = idup(curproc->cwd);
3250   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
3251 
3252   acquire(&ptable.lock);
3253   np->state = RUNNABLE;
3254   release(&ptable.lock);
3255   return np->tid;
3256 }
3257 
3258   void
3259 thread_exit(void* retval)
3260 {
3261   struct proc *curproc = myproc();
3262   struct proc *p;
3263   int fd;
3264 
3265   if(curproc == initproc)
3266     panic("init exiting");
3267 
3268   
3269   for(fd = 0; fd < NOFILE; fd++){
3270     if(curproc->ofile[fd]){
3271       fileclose(curproc->ofile[fd]);
3272       curproc->ofile[fd] = 0;
3273     }
3274   }
3275 
3276   begin_op();
3277   iput(curproc->cwd);
3278   end_op();
3279   curproc->cwd = 0;
3280   
3281   curproc->tf->eax = (uint)retval;
3282   acquire(&ptable.lock);
3283 
3284   
3285   wakeup1(curproc->parent);
3286   
3287   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3288     if(p->parent == curproc){
3289       p->parent = initproc;
3290       if(p->state == ZOMBIE)
3291         wakeup1(initproc);
3292     }
3293   }
3294 
3295   
3296   curproc->state = ZOMBIE;
3297   sched();
3298   panic("zombie exit");
3299 }
3300 
3301 
3302   int
3303 thread_join(int tid, void** retval)
3304 {
3305   
3306   struct proc *p;
3307   int havekids;
3308   struct proc *curproc = myproc();
3309   
3310   acquire(&ptable.lock);
3311   for(;;){
3312     
3313     havekids = 0;
3314     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3315       if(curproc->pid != p->pid || p->tid != tid)
3316         continue;
3317       
3318       /*
3319          if(p->tf->eax == (void*)0x87654321)
3320          cprintf("eax correct\n");
3321          else
3322          cprintf("eax wrong\n");*/
3323 
3324       havekids = 1;
3325       if(p->state == ZOMBIE){
3326         curproc->tcnt -= 1;
3327         *retval = (void*)p->tf->eax;
3328         
3329         
3330         
3331         kfree(p->kstack);
3332         p->kstack = 0;
3333         
3334         freevm(p->pgdir);
3335         p->pid = 0;
3336         p->parent = 0;
3337         p->name[0] = 0;
3338         p->killed = 0;
3339         p->state = UNUSED;
3340         release(&ptable.lock);
3341         
3342         return 0;
3343       }
3344     }
3345 
3346 
3347 
3348 
3349 
3350     
3351     if(!havekids || curproc->killed){
3352       release(&ptable.lock);
3353       
3354       return -1;
3355     }
3356 
3357     
3358     sleep(curproc, &ptable.lock);  
3359   }
3360 }
3361 
3362 int gettid()
3363 {
3364   struct proc *curproc = myproc();
3365   return (int)curproc->tid;
3366 }
3367 
3368 
3369 
3370 
3371 
3372 
3373 
3374 
3375 
3376 
3377 
3378 
3379 
3380 
3381 
3382 
3383 
3384 
3385 
3386 
3387 
3388 
3389 
3390 
3391 
3392 
3393 
3394 
3395 
3396 
3397 
3398 
3399 
3400 
3401 
3402 
3403 
3404 
3405 
3406 
3407 
3408 .globl swtch
3409 swtch:
3410   movl 4(%esp), %eax
3411   movl 8(%esp), %edx
3412 
3413   
3414   pushl %ebp
3415   pushl %ebx
3416   pushl %esi
3417   pushl %edi
3418 
3419   
3420   movl %esp, (%eax)
3421   movl %edx, %esp
3422 
3423   
3424   popl %edi
3425   popl %esi
3426   popl %ebx
3427   popl %ebp
3428   ret
3429 
3430 
3431 
3432 
3433 
3434 
3435 
3436 
3437 
3438 
3439 
3440 
3441 
3442 
3443 
3444 
3445 
3446 
3447 
3448 
3449 
3450 
3451 
3452 
3453 
3454 #include "types.h"
3455 #include "defs.h"
3456 #include "param.h"
3457 #include "memlayout.h"
3458 #include "mmu.h"
3459 #include "spinlock.h"
3460 
3461 void freerange(void *vstart, void *vend);
3462 extern char end[]; 
3463                    
3464 
3465 struct run {
3466   struct run *next;
3467 };
3468 
3469 struct {
3470   struct spinlock lock;
3471   int use_lock;
3472   struct run *freelist;
3473 } kmem;
3474 
3475 
3476 
3477 
3478 
3479 
3480 void
3481 kinit1(void *vstart, void *vend)
3482 {
3483   initlock(&kmem.lock, "kmem");
3484   kmem.use_lock = 0;
3485   freerange(vstart, vend);
3486 }
3487 
3488 void
3489 kinit2(void *vstart, void *vend)
3490 {
3491   freerange(vstart, vend);
3492   kmem.use_lock = 1;
3493 }
3494 
3495 
3496 
3497 
3498 
3499 
3500 void
3501 freerange(void *vstart, void *vend)
3502 {
3503   char *p;
3504   p = (char*)PGROUNDUP((uint)vstart);
3505   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
3506     kfree(p);
3507 }
3508 
3509 
3510 
3511 
3512 
3513 void
3514 kfree(char *v)
3515 {
3516   struct run *r;
3517 
3518   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
3519     panic("kfree");
3520 
3521   
3522   memset(v, 1, PGSIZE);
3523 
3524   if(kmem.use_lock)
3525     acquire(&kmem.lock);
3526   r = (struct run*)v;
3527   r->next = kmem.freelist;
3528   kmem.freelist = r;
3529   if(kmem.use_lock)
3530     release(&kmem.lock);
3531 }
3532 
3533 
3534 
3535 
3536 char*
3537 kalloc(void)
3538 {
3539   struct run *r;
3540 
3541   if(kmem.use_lock)
3542     acquire(&kmem.lock);
3543   r = kmem.freelist;
3544   if(r)
3545     kmem.freelist = r->next;
3546   if(kmem.use_lock)
3547     release(&kmem.lock);
3548   return (char*)r;
3549 }
3550 
3551 
3552 
3553 #define T_DIVIDE         0      
3554 #define T_DEBUG          1      
3555 #define T_NMI            2      
3556 #define T_BRKPT          3      
3557 #define T_OFLOW          4      
3558 #define T_BOUND          5      
3559 #define T_ILLOP          6      
3560 #define T_DEVICE         7      
3561 #define T_DBLFLT         8      
3562 
3563 #define T_TSS           10      
3564 #define T_SEGNP         11      
3565 #define T_STACK         12      
3566 #define T_GPFLT         13      
3567 #define T_PGFLT         14      
3568 
3569 #define T_FPERR         16      
3570 #define T_ALIGN         17      
3571 #define T_MCHK          18      
3572 #define T_SIMDERR       19      
3573 
3574 
3575 
3576 #define T_SYSCALL       64      
3577 #define T_DEFAULT      500      
3578 
3579 #define T_IRQ0          32      
3580 
3581 #define IRQ_TIMER        0
3582 #define IRQ_KBD          1
3583 #define IRQ_COM1         4
3584 #define IRQ_IDE         14
3585 #define IRQ_ERROR       19
3586 #define IRQ_SPURIOUS    31
3587 
3588 
3589 
3590 
3591 
3592 
3593 
3594 
3595 
3596 
3597 
3598 
3599 
3600 #!/usr/bin/perl -w
3601 
3602 # Generate vectors.S, the trap/interrupt entry points.
3603 # There has to be one entry point per interrupt number
3604 # since otherwise there's no way for trap() to discover
3605 # the interrupt number.
3606 
3607 print "# generated by vectors.pl - do not edit\n";
3608 print "# handlers\n";
3609 print ".globl alltraps\n";
3610 for(my $i = 0; $i < 256; $i++){
3611     print ".globl vector$i\n";
3612     print "vector$i:\n";
3613     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
3614         print "  pushl \$0\n";
3615     }
3616     print "  pushl \$$i\n";
3617     print "  jmp alltraps\n";
3618 }
3619 
3620 print "\n# vector table\n";
3621 print ".data\n";
3622 print ".globl vectors\n";
3623 print "vectors:\n";
3624 for(my $i = 0; $i < 256; $i++){
3625     print "  .long vector$i\n";
3626 }
3627 
3628 # sample output:
3629 #   # handlers
3630 #   .globl alltraps
3631 #   .globl vector0
3632 #   vector0:
3633 #     pushl $0
3634 #     pushl $0
3635 #     jmp alltraps
3636 #   ...
3637 #
3638 #   # vector table
3639 #   .data
3640 #   .globl vectors
3641 #   vectors:
3642 #     .long vector0
3643 #     .long vector1
3644 #     .long vector2
3645 #   ...
3646 
3647 
3648 
3649 
3650 
3651 
3652   
3653 .globl alltraps
3654 alltraps:
3655   
3656   pushl %ds
3657   pushl %es
3658   pushl %fs
3659   pushl %gs
3660   pushal
3661 
3662   
3663   movw $(SEG_KDATA<<3), %ax
3664   movw %ax, %ds
3665   movw %ax, %es
3666 
3667   
3668   pushl %esp
3669   call trap
3670   addl $4, %esp
3671 
3672   
3673 .globl trapret
3674 trapret:
3675   popal
3676   popl %gs
3677   popl %fs
3678   popl %es
3679   popl %ds
3680   addl $0x8, %esp  
3681   iret
3682 
3683 
3684 
3685 
3686 
3687 
3688 
3689 
3690 
3691 
3692 
3693 
3694 
3695 
3696 
3697 
3698 
3699 
3700 #include "types.h"
3701 #include "defs.h"
3702 #include "param.h"
3703 #include "memlayout.h"
3704 #include "mmu.h"
3705 #include "proc.h"
3706 #include "x86.h"
3707 #include "traps.h"
3708 #include "spinlock.h"
3709 
3710 
3711 struct gatedesc idt[256];
3712 extern uint vectors[];  
3713 struct spinlock tickslock;
3714 uint ticks;
3715 
3716 void
3717 tvinit(void)
3718 {
3719   int i;
3720 
3721   for(i = 0; i < 256; i++)
3722     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
3723   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
3724 
3725   initlock(&tickslock, "time");
3726 }
3727 
3728 void
3729 idtinit(void)
3730 {
3731   lidt(idt, sizeof(idt));
3732 }
3733 
3734 
3735 
3736 
3737 
3738 
3739 
3740 
3741 
3742 
3743 
3744 
3745 
3746 
3747 
3748 
3749 
3750 void
3751 trap(struct trapframe *tf)
3752 {
3753   if(tf->trapno == T_SYSCALL){
3754     if(myproc()->killed)
3755       exit();
3756     myproc()->tf = tf;
3757     syscall();
3758     if(myproc()->killed)
3759       exit();
3760     return;
3761   }
3762 
3763   switch(tf->trapno){
3764   case T_IRQ0 + IRQ_TIMER:
3765     if(cpuid() == 0){
3766       acquire(&tickslock);
3767       ticks++;
3768       wakeup(&ticks);
3769       release(&tickslock);
3770     }
3771     lapiceoi();
3772     break;
3773   case T_IRQ0 + IRQ_IDE:
3774     ideintr();
3775     lapiceoi();
3776     break;
3777   case T_IRQ0 + IRQ_IDE+1:
3778     
3779     break;
3780   case T_IRQ0 + IRQ_KBD:
3781     kbdintr();
3782     lapiceoi();
3783     break;
3784   case T_IRQ0 + IRQ_COM1:
3785     uartintr();
3786     lapiceoi();
3787     break;
3788   case T_IRQ0 + 7:
3789   case T_IRQ0 + IRQ_SPURIOUS:
3790     cprintf("cpu%d: spurious interrupt at %x:%x\n",
3791             cpuid(), tf->cs, tf->eip);
3792     lapiceoi();
3793     break;
3794 
3795 
3796 
3797 
3798 
3799 
3800   default:
3801     if(myproc() == 0 || (tf->cs&3) == 0){
3802       
3803       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
3804               tf->trapno, cpuid(), tf->eip, rcr2());
3805       panic("trap");
3806     }
3807     
3808     cprintf("pid %d %s: trap %d err %d on cpu %d "
3809             "eip 0x%x addr 0x%x--kill proc\n",
3810             myproc()->pid, myproc()->name, tf->trapno,
3811             tf->err, cpuid(), tf->eip, rcr2());
3812     myproc()->killed = 1;
3813   }
3814 
3815   
3816   
3817   
3818   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3819     exit();
3820 
3821   
3822   
3823   if(myproc() && myproc()->state == RUNNING &&
3824      tf->trapno == T_IRQ0+IRQ_TIMER)
3825     yield();
3826 
3827   
3828   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3829     exit();
3830 }
3831 
3832 
3833 
3834 
3835 
3836 
3837 
3838 
3839 
3840 
3841 
3842 
3843 
3844 
3845 
3846 
3847 
3848 
3849 
3850 
3851 #define SYS_fork	 1
3852 #define SYS_exit	 2
3853 #define SYS_wait	 3
3854 #define SYS_pipe	 4
3855 #define SYS_read	 5
3856 #define SYS_kill	 6
3857 #define SYS_exec	 7
3858 #define SYS_fstat	 8
3859 #define SYS_chdir	 9
3860 #define SYS_dup		10
3861 #define SYS_getpid	11
3862 #define SYS_sbrk	12
3863 #define SYS_sleep	13
3864 #define SYS_uptime	14
3865 #define SYS_open	15
3866 #define SYS_write	16
3867 #define SYS_mknod	17
3868 #define SYS_unlink	18
3869 #define SYS_link	19
3870 #define SYS_mkdir	20
3871 #define SYS_close	21
3872 #define SYS_halt	22
3873 #define SYS_getnice 23
3874 #define SYS_setnice 24
3875 #define SYS_ps      25
3876 #define SYS_thread_create  26
3877 #define SYS_thread_exit      27
3878 #define SYS_thread_join      28
3879 #define SYS_gettid      29
3880 #define SYS_mutex_init 30
3881 #define SYS_mutex_lock 31
3882 #define SYS_mutex_unlock 32
3883 #define SYS_cond_init 33
3884 #define SYS_cond_wait 34
3885 #define SYS_cond_signal 35
3886 
3887 
3888 
3889 
3890 
3891 
3892 
3893 
3894 
3895 
3896 
3897 
3898 
3899 
3900 #include "types.h"
3901 #include "defs.h"
3902 #include "param.h"
3903 #include "memlayout.h"
3904 #include "mmu.h"
3905 #include "proc.h"
3906 #include "x86.h"
3907 #include "syscall.h"
3908 
3909 
3910 
3911 
3912 
3913 
3914 
3915 
3916 int
3917 fetchint(uint addr, int *ip)
3918 {
3919   struct proc *curproc = myproc();
3920 
3921   if(addr >= curproc->sz || addr+4 > curproc->sz)
3922     return -1;
3923   *ip = *(int*)(addr);
3924   return 0;
3925 }
3926 
3927 
3928 
3929 
3930 int
3931 fetchstr(uint addr, char **pp)
3932 {
3933   char *s, *ep;
3934   struct proc *curproc = myproc();
3935 
3936   if(addr >= curproc->sz)
3937     return -1;
3938   *pp = (char*)addr;
3939   ep = (char*)curproc->sz;
3940   for(s = *pp; s < ep; s++){
3941     if(*s == 0)
3942       return s - *pp;
3943   }
3944   return -1;
3945 }
3946 
3947 
3948 
3949 
3950 
3951 int
3952 argint(int n, int *ip)
3953 {
3954   return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
3955 }
3956 
3957 
3958 
3959 
3960 int
3961 argptr(int n, char **pp, int size)
3962 {
3963   int i;
3964   struct proc *curproc = myproc();
3965 
3966   if(argint(n, &i) < 0){
3967     cprintf("err1\n");
3968     return -1;
3969   }
3970   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz){
3971     cprintf("err2\n");
3972     return -1;
3973   }
3974   *pp = (char*)i;
3975   return 0;
3976 }
3977 
3978 
3979 
3980 
3981 
3982 int
3983 argstr(int n, char **pp)
3984 {
3985   int addr;
3986   if(argint(n, &addr) < 0)
3987     return -1;
3988   return fetchstr(addr, pp);
3989 }
3990 
3991 
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 extern int sys_chdir(void);
4001 extern int sys_close(void);
4002 extern int sys_dup(void);
4003 extern int sys_exec(void);
4004 extern int sys_exit(void);
4005 extern int sys_fork(void);
4006 extern int sys_fstat(void);
4007 extern int sys_getpid(void);
4008 extern int sys_kill(void);
4009 extern int sys_link(void);
4010 extern int sys_mkdir(void);
4011 extern int sys_mknod(void);
4012 extern int sys_open(void);
4013 extern int sys_pipe(void);
4014 extern int sys_read(void);
4015 extern int sys_sbrk(void);
4016 extern int sys_sleep(void);
4017 extern int sys_unlink(void);
4018 extern int sys_wait(void);
4019 extern int sys_write(void);
4020 extern int sys_uptime(void);
4021 extern int sys_halt(void);
4022 extern int sys_getnice(void);
4023 extern int sys_setnice(void);
4024 extern int sys_ps(void);
4025 extern int sys_thread_create(void);
4026 extern int sys_thread_exit(void);
4027 extern int sys_thread_join(void);
4028 extern int sys_gettid(void);
4029 extern int sys_mutex_init(void);
4030 extern int sys_mutex_lock(void);
4031 extern int sys_mutex_unlock(void);
4032 extern int sys_cond_init(void);
4033 extern int sys_cond_wait(void);
4034 extern int sys_cond_signla(void);
4035 
4036 static int (*syscalls[])(void) = {
4037 [SYS_fork]    sys_fork,
4038 [SYS_exit]    sys_exit,
4039 [SYS_wait]    sys_wait,
4040 [SYS_pipe]    sys_pipe,
4041 [SYS_read]    sys_read,
4042 [SYS_kill]    sys_kill,
4043 [SYS_exec]    sys_exec,
4044 [SYS_fstat]   sys_fstat,
4045 [SYS_chdir]   sys_chdir,
4046 [SYS_dup]     sys_dup,
4047 [SYS_getpid]  sys_getpid,
4048 [SYS_sbrk]    sys_sbrk,
4049 [SYS_sleep]   sys_sleep,
4050 [SYS_uptime]  sys_uptime,
4051 [SYS_open]    sys_open,
4052 [SYS_write]   sys_write,
4053 [SYS_mknod]   sys_mknod,
4054 [SYS_unlink]  sys_unlink,
4055 [SYS_link]    sys_link,
4056 [SYS_mkdir]   sys_mkdir,
4057 [SYS_close]   sys_close,
4058 [SYS_halt]    sys_halt,
4059 [SYS_getnice] sys_getnice,
4060 [SYS_setnice] sys_setnice,
4061 [SYS_ps]      sys_ps,
4062 [SYS_thread_create]      sys_thread_create,
4063 [SYS_thread_exit]      sys_thread_exit,
4064 [SYS_thread_join]      sys_thread_join,
4065 [SYS_gettid]      sys_gettid,
4066 [SYS_mutex_init] sys_mutex_init,
4067 [SYS_mutex_lock] sys_mutex_lock,
4068 [SYS_mutex_unlock] sys_mutex_unlock,
4069 [SYS_cond_init] sys_cond_init,
4070 [SYS_cond_wait] sys_cond_wait,
4071 [SYS_cond_signal] sys_cond_signal,
4072 };
4073 
4074 
4075 void
4076 syscall(void)
4077 {
4078   int num;
4079   struct proc *curproc = myproc();
4080 
4081   num = curproc->tf->eax;
4082   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
4083     curproc->tf->eax = syscalls[num]();
4084   } else {
4085     cprintf("%d %s: unknown sys call %d\n",
4086             curproc->pid, curproc->name, num);
4087     curproc->tf->eax = -1;
4088   }
4089 }
4090 
4091 
4092 
4093 
4094 
4095 
4096 
4097 
4098 
4099 
4100 #include "types.h"
4101 #include "x86.h"
4102 #include "defs.h"
4103 #include "date.h"
4104 #include "param.h"
4105 #include "memlayout.h"
4106 #include "mmu.h"
4107 #include "proc.h"
4108 #include "synch.h"
4109 
4110 int
4111 sys_fork(void)
4112 {
4113   return fork();
4114 }
4115 
4116 int
4117 sys_exit(void)
4118 {
4119   exit();
4120   return 0;  
4121 }
4122 
4123 int
4124 sys_wait(void)
4125 {
4126   return wait();
4127 }
4128 
4129 int
4130 sys_kill(void)
4131 {
4132   int pid;
4133 
4134   if(argint(0, &pid) < 0)
4135     return -1;
4136   return kill(pid);
4137 }
4138 
4139 int
4140 sys_getpid(void)
4141 {
4142   return myproc()->pid;
4143 }
4144 
4145 
4146 
4147 
4148 
4149 
4150 int
4151 sys_sbrk(void)
4152 {
4153   int addr;
4154   int n;
4155 
4156   if(argint(0, &n) < 0)
4157     return -1;
4158   addr = myproc()->sz;
4159   if(growproc(n) < 0)
4160     return -1;
4161   return addr;
4162 }
4163 
4164 int
4165 sys_sleep(void)
4166 {
4167   int n;
4168   uint ticks0;
4169 
4170   if(argint(0, &n) < 0)
4171     return -1;
4172   acquire(&tickslock);
4173   ticks0 = ticks;
4174   while(ticks - ticks0 < n){
4175     if(myproc()->killed){
4176       release(&tickslock);
4177       return -1;
4178     }
4179     sleep(&ticks, &tickslock);
4180   }
4181   release(&tickslock);
4182   return 0;
4183 }
4184 
4185 
4186 
4187 int
4188 sys_uptime(void)
4189 {
4190   uint xticks;
4191 
4192   acquire(&tickslock);
4193   xticks = ticks;
4194   release(&tickslock);
4195   return xticks;
4196 }
4197 
4198 
4199 
4200 int
4201 sys_halt(void)
4202 {
4203   outw(0x604, 0x2000);
4204   return 0;
4205 }
4206 
4207 int
4208 sys_getnice(void)
4209 {
4210   int pid;
4211 
4212   if(argint(0, &pid) < 0)
4213     return -1;
4214   return getnice(pid);
4215 }
4216 
4217 int
4218 sys_setnice(void)
4219 {
4220 	int pid, value;
4221 
4222 	if(argint(0, &pid) < 0)
4223 		return -1;
4224 	if(argint(1, &value) < 0)
4225 		return -1;
4226 	return setnice(pid, value);
4227 }
4228 
4229 void
4230 sys_ps(void)
4231 {
4232 	int pid;
4233 
4234 	if(argint(0, &pid) >= 0){
4235     ps(pid);
4236   }
4237 }
4238 
4239 
4240 
4241 
4242 
4243 
4244 
4245 
4246 
4247 
4248 
4249 
4250 int
4251 sys_thread_create(void)
4252 {
4253   int function, arg, stack;
4254   if(argint(0, &function) < 0)
4255     return -1;
4256   if(argint(1, &arg) < 0)
4257     return -1;
4258   if(argint(2, &stack) < 0)
4259     return -1;
4260   return thread_create((void*)function, (void*)arg, (void*)stack);
4261 }
4262 
4263 void
4264 sys_thread_exit(void)
4265 {
4266   int retval;
4267   if(argint(0, &retval) < 0)
4268     return;
4269   thread_exit((void*)retval);
4270 }
4271 
4272 int
4273 sys_thread_join(void)
4274 {
4275   int tid;
4276   int retval;
4277   if(argint(0, &tid) < 0)
4278     return -1;
4279   if(argint(1, &retval) < 0)
4280     return -1;
4281   return thread_join(tid, (void*)retval);
4282 }
4283 
4284 int
4285 sys_gettid(void)
4286 {
4287   int tid;
4288   if(argint(0, &tid) < 0)
4289     return -1;
4290   return gettid(tid);
4291 }
4292 
4293 
4294 
4295 
4296 
4297 
4298 
4299 
4300 int
4301 sys_mutex_init(void)
4302 {
4303   int mutex;
4304   if(argint(0, &mutex) < 0)
4305     return -1;
4306   return mutex_init((struct mutex_t*)mutex);
4307 }
4308 int
4309 sys_mutex_lock(void)
4310 {
4311   int mutex;
4312   if(argint(0, &mutex) < 0)
4313     return -1;
4314   return mutex_lock((struct mutex_t*)mutex);
4315 }
4316 
4317 int
4318 sys_mutex_unlock(void)
4319 {
4320   int mutex;
4321   if(argint(0, &mutex) < 0)
4322     return -1;
4323   return mutex_unlock((struct mutex_t*)mutex);
4324 }
4325 
4326 
4327 int
4328 sys_cond_init(void)
4329 {
4330   int cv;
4331   if(argint(0, &cv) < 0)
4332     return -1;
4333   return cond_init((struct cond_t*)cv);
4334 }
4335 
4336 int
4337 sys_cond_wait(void)
4338 {
4339   int mutex, cv;
4340   if(argint(0, &cv) < 0)
4341     return -1;
4342   if(argint(1, &mutex) < 0)
4343     return -1;
4344   return cond_wait((struct cond_t*)cv, (struct mutex_t*)mutex);
4345 }
4346 
4347 
4348 
4349 
4350 int
4351 sys_cond_signal(void)
4352 {
4353   int cv;
4354   if(argint(0, &cv) < 0)
4355     return -1;
4356   return cond_signal((struct cond_t*)cv);
4357 }
4358 
4359 
4360 
4361 
4362 
4363 
4364 
4365 
4366 
4367 
4368 
4369 
4370 
4371 
4372 
4373 
4374 
4375 
4376 
4377 
4378 
4379 
4380 
4381 
4382 
4383 
4384 
4385 
4386 
4387 
4388 
4389 
4390 
4391 
4392 
4393 
4394 
4395 
4396 
4397 
4398 
4399 
4400 struct buf {
4401   int flags;
4402   uint dev;
4403   uint blockno;
4404   struct sleeplock lock;
4405   uint refcnt;
4406   struct buf *prev; 
4407   struct buf *next;
4408   struct buf *qnext; 
4409   uchar data[BSIZE];
4410 };
4411 #define B_VALID 0x2  
4412 #define B_DIRTY 0x4  
4413 
4414 
4415 
4416 
4417 
4418 
4419 
4420 
4421 
4422 
4423 
4424 
4425 
4426 
4427 
4428 
4429 
4430 
4431 
4432 
4433 
4434 
4435 
4436 
4437 
4438 
4439 
4440 
4441 
4442 
4443 
4444 
4445 
4446 
4447 
4448 
4449 
4450 
4451 struct sleeplock {
4452   uint locked;       
4453   struct spinlock lk; 
4454 
4455   
4456   char *name;        
4457   int pid;           
4458 };
4459 
4460 
4461 
4462 
4463 
4464 
4465 
4466 
4467 
4468 
4469 
4470 
4471 
4472 
4473 
4474 
4475 
4476 
4477 
4478 
4479 
4480 
4481 
4482 
4483 
4484 
4485 
4486 
4487 
4488 
4489 
4490 
4491 
4492 
4493 
4494 
4495 
4496 
4497 
4498 
4499 
4500 #define O_RDONLY  0x000
4501 #define O_WRONLY  0x001
4502 #define O_RDWR    0x002
4503 #define O_CREATE  0x200
4504 
4505 
4506 
4507 
4508 
4509 
4510 
4511 
4512 
4513 
4514 
4515 
4516 
4517 
4518 
4519 
4520 
4521 
4522 
4523 
4524 
4525 
4526 
4527 
4528 
4529 
4530 
4531 
4532 
4533 
4534 
4535 
4536 
4537 
4538 
4539 
4540 
4541 
4542 
4543 
4544 
4545 
4546 
4547 
4548 
4549 
4550 #define T_DIR  1   
4551 #define T_FILE 2   
4552 #define T_DEV  3   
4553 
4554 struct stat {
4555   short type;  
4556   int dev;     
4557   uint ino;    
4558   short nlink; 
4559   uint size;   
4560 };
4561 
4562 
4563 
4564 
4565 
4566 
4567 
4568 
4569 
4570 
4571 
4572 
4573 
4574 
4575 
4576 
4577 
4578 
4579 
4580 
4581 
4582 
4583 
4584 
4585 
4586 
4587 
4588 
4589 
4590 
4591 
4592 
4593 
4594 
4595 
4596 
4597 
4598 
4599 
4600 
4601 
4602 
4603 
4604 #define ROOTINO 1  
4605 #define BSIZE 512  
4606 
4607 
4608 
4609 
4610 
4611 
4612 
4613 struct superblock {
4614   uint size;         
4615   uint nblocks;      
4616   uint ninodes;      
4617   uint nlog;         
4618   uint logstart;     
4619   uint inodestart;   
4620   uint bmapstart;    
4621 };
4622 
4623 #define NDIRECT 12
4624 #define NINDIRECT (BSIZE / sizeof(uint))
4625 #define MAXFILE (NDIRECT + NINDIRECT)
4626 
4627 
4628 struct dinode {
4629   short type;           
4630   short major;          
4631   short minor;          
4632   short nlink;          
4633   uint size;            
4634   uint addrs[NDIRECT+1];   
4635 };
4636 
4637 
4638 
4639 
4640 
4641 
4642 
4643 
4644 
4645 
4646 
4647 
4648 
4649 
4650 
4651 #define IPB           (BSIZE / sizeof(struct dinode))
4652 
4653 
4654 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
4655 
4656 
4657 #define BPB           (BSIZE*8)
4658 
4659 
4660 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
4661 
4662 
4663 #define DIRSIZ 14
4664 
4665 struct dirent {
4666   ushort inum;
4667   char name[DIRSIZ];
4668 };
4669 
4670 
4671 
4672 
4673 
4674 
4675 
4676 
4677 
4678 
4679 
4680 
4681 
4682 
4683 
4684 
4685 
4686 
4687 
4688 
4689 
4690 
4691 
4692 
4693 
4694 
4695 
4696 
4697 
4698 
4699 
4700 struct file {
4701   enum { FD_NONE, FD_PIPE, FD_INODE } type;
4702   int ref; 
4703   char readable;
4704   char writable;
4705   struct pipe *pipe;
4706   struct inode *ip;
4707   uint off;
4708 };
4709 
4710 
4711 
4712 struct inode {
4713   uint dev;           
4714   uint inum;          
4715   int ref;            
4716   struct sleeplock lock; 
4717   int valid;          
4718 
4719   short type;         
4720   short major;
4721   short minor;
4722   short nlink;
4723   uint size;
4724   uint addrs[NDIRECT+1];
4725 };
4726 
4727 
4728 
4729 struct devsw {
4730   int (*read)(struct inode*, char*, int);
4731   int (*write)(struct inode*, char*, int);
4732 };
4733 
4734 extern struct devsw devsw[];
4735 
4736 #define CONSOLE 1
4737 
4738 
4739 
4740 
4741 
4742 
4743 
4744 
4745 
4746 
4747 
4748 
4749 
4750 
4751 
4752 #include "types.h"
4753 #include "defs.h"
4754 #include "param.h"
4755 #include "memlayout.h"
4756 #include "mmu.h"
4757 #include "proc.h"
4758 #include "x86.h"
4759 #include "traps.h"
4760 #include "spinlock.h"
4761 #include "sleeplock.h"
4762 #include "fs.h"
4763 #include "buf.h"
4764 
4765 #define SECTOR_SIZE   512
4766 #define IDE_BSY       0x80
4767 #define IDE_DRDY      0x40
4768 #define IDE_DF        0x20
4769 #define IDE_ERR       0x01
4770 
4771 #define IDE_CMD_READ  0x20
4772 #define IDE_CMD_WRITE 0x30
4773 #define IDE_CMD_RDMUL 0xc4
4774 #define IDE_CMD_WRMUL 0xc5
4775 
4776 
4777 
4778 
4779 
4780 static struct spinlock idelock;
4781 static struct buf *idequeue;
4782 
4783 static int havedisk1;
4784 static void idestart(struct buf*);
4785 
4786 
4787 static int
4788 idewait(int checkerr)
4789 {
4790   int r;
4791 
4792   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
4793     ;
4794   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
4795     return -1;
4796   return 0;
4797 }
4798 
4799 
4800 void
4801 ideinit(void)
4802 {
4803   int i;
4804 
4805   initlock(&idelock, "ide");
4806   ioapicenable(IRQ_IDE, ncpu - 1);
4807   idewait(0);
4808 
4809   
4810   outb(0x1f6, 0xe0 | (1<<4));
4811   for(i=0; i<1000; i++){
4812     if(inb(0x1f7) != 0){
4813       havedisk1 = 1;
4814       break;
4815     }
4816   }
4817 
4818   
4819   outb(0x1f6, 0xe0 | (0<<4));
4820 }
4821 
4822 
4823 static void
4824 idestart(struct buf *b)
4825 {
4826   if(b == 0)
4827     panic("idestart");
4828   if(b->blockno >= FSSIZE)
4829     panic("incorrect blockno");
4830   int sector_per_block =  BSIZE/SECTOR_SIZE;
4831   int sector = b->blockno * sector_per_block;
4832   int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
4833   int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
4834 
4835   if (sector_per_block > 7) panic("idestart");
4836 
4837   idewait(0);
4838   outb(0x3f6, 0);  
4839   outb(0x1f2, sector_per_block);  
4840   outb(0x1f3, sector & 0xff);
4841   outb(0x1f4, (sector >> 8) & 0xff);
4842   outb(0x1f5, (sector >> 16) & 0xff);
4843   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
4844   if(b->flags & B_DIRTY){
4845     outb(0x1f7, write_cmd);
4846     outsl(0x1f0, b->data, BSIZE/4);
4847   } else {
4848     outb(0x1f7, read_cmd);
4849   }
4850 }
4851 
4852 
4853 void
4854 ideintr(void)
4855 {
4856   struct buf *b;
4857 
4858   
4859   acquire(&idelock);
4860 
4861   if((b = idequeue) == 0){
4862     release(&idelock);
4863     return;
4864   }
4865   idequeue = b->qnext;
4866 
4867   
4868   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
4869     insl(0x1f0, b->data, BSIZE/4);
4870 
4871   
4872   b->flags |= B_VALID;
4873   b->flags &= ~B_DIRTY;
4874   wakeup(b);
4875 
4876   
4877   if(idequeue != 0)
4878     idestart(idequeue);
4879 
4880   release(&idelock);
4881 }
4882 
4883 
4884 
4885 
4886 
4887 
4888 
4889 
4890 
4891 
4892 
4893 
4894 
4895 
4896 
4897 
4898 
4899 
4900 
4901 
4902 
4903 void
4904 iderw(struct buf *b)
4905 {
4906   struct buf **pp;
4907 
4908   if(!holdingsleep(&b->lock))
4909     panic("iderw: buf not locked");
4910   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
4911     panic("iderw: nothing to do");
4912   if(b->dev != 0 && !havedisk1)
4913     panic("iderw: ide disk 1 not present");
4914 
4915   acquire(&idelock);  
4916 
4917   
4918   b->qnext = 0;
4919   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
4920     ;
4921   *pp = b;
4922 
4923   
4924   if(idequeue == b)
4925     idestart(b);
4926 
4927   
4928   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
4929     sleep(b, &idelock);
4930   }
4931 
4932 
4933   release(&idelock);
4934 }
4935 
4936 
4937 
4938 
4939 
4940 
4941 
4942 
4943 
4944 
4945 
4946 
4947 
4948 
4949 
4950 
4951 
4952 
4953 
4954 
4955 
4956 
4957 
4958 
4959 
4960 
4961 
4962 
4963 
4964 
4965 
4966 
4967 
4968 
4969 
4970 #include "types.h"
4971 #include "defs.h"
4972 #include "param.h"
4973 #include "spinlock.h"
4974 #include "sleeplock.h"
4975 #include "fs.h"
4976 #include "buf.h"
4977 
4978 struct {
4979   struct spinlock lock;
4980   struct buf buf[NBUF];
4981 
4982   
4983   
4984   struct buf head;
4985 } bcache;
4986 
4987 void
4988 binit(void)
4989 {
4990   struct buf *b;
4991 
4992   initlock(&bcache.lock, "bcache");
4993 
4994 
4995 
4996 
4997 
4998 
4999 
5000   
5001   bcache.head.prev = &bcache.head;
5002   bcache.head.next = &bcache.head;
5003   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
5004     b->next = bcache.head.next;
5005     b->prev = &bcache.head;
5006     initsleeplock(&b->lock, "buffer");
5007     bcache.head.next->prev = b;
5008     bcache.head.next = b;
5009   }
5010 }
5011 
5012 
5013 
5014 
5015 static struct buf*
5016 bget(uint dev, uint blockno)
5017 {
5018   struct buf *b;
5019 
5020   acquire(&bcache.lock);
5021 
5022   
5023   for(b = bcache.head.next; b != &bcache.head; b = b->next){
5024     if(b->dev == dev && b->blockno == blockno){
5025       b->refcnt++;
5026       release(&bcache.lock);
5027       acquiresleep(&b->lock);
5028       return b;
5029     }
5030   }
5031 
5032   
5033   
5034   
5035   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
5036     if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
5037       b->dev = dev;
5038       b->blockno = blockno;
5039       b->flags = 0;
5040       b->refcnt = 1;
5041       release(&bcache.lock);
5042       acquiresleep(&b->lock);
5043       return b;
5044     }
5045   }
5046   panic("bget: no buffers");
5047 }
5048 
5049 
5050 
5051 struct buf*
5052 bread(uint dev, uint blockno)
5053 {
5054   struct buf *b;
5055 
5056   b = bget(dev, blockno);
5057   if((b->flags & B_VALID) == 0) {
5058     iderw(b);
5059   }
5060   return b;
5061 }
5062 
5063 
5064 void
5065 bwrite(struct buf *b)
5066 {
5067   if(!holdingsleep(&b->lock))
5068     panic("bwrite");
5069   b->flags |= B_DIRTY;
5070   iderw(b);
5071 }
5072 
5073 
5074 
5075 void
5076 brelse(struct buf *b)
5077 {
5078   if(!holdingsleep(&b->lock))
5079     panic("brelse");
5080 
5081   releasesleep(&b->lock);
5082 
5083   acquire(&bcache.lock);
5084   b->refcnt--;
5085   if (b->refcnt == 0) {
5086     
5087     b->next->prev = b->prev;
5088     b->prev->next = b->next;
5089     b->next = bcache.head.next;
5090     b->prev = &bcache.head;
5091     bcache.head.next->prev = b;
5092     bcache.head.next = b;
5093   }
5094 
5095   release(&bcache.lock);
5096 }
5097 
5098 
5099 
5100 
5101 
5102 
5103 
5104 
5105 
5106 
5107 
5108 
5109 
5110 
5111 
5112 
5113 
5114 
5115 
5116 
5117 
5118 
5119 
5120 
5121 
5122 
5123 
5124 
5125 
5126 
5127 
5128 
5129 
5130 
5131 
5132 
5133 
5134 
5135 
5136 
5137 
5138 
5139 
5140 
5141 
5142 
5143 
5144 
5145 
5146 
5147 
5148 
5149 
5150 
5151 
5152 #include "types.h"
5153 #include "defs.h"
5154 #include "param.h"
5155 #include "x86.h"
5156 #include "memlayout.h"
5157 #include "mmu.h"
5158 #include "proc.h"
5159 #include "spinlock.h"
5160 #include "sleeplock.h"
5161 
5162 void
5163 initsleeplock(struct sleeplock *lk, char *name)
5164 {
5165   initlock(&lk->lk, "sleep lock");
5166   lk->name = name;
5167   lk->locked = 0;
5168   lk->pid = 0;
5169 }
5170 
5171 void
5172 acquiresleep(struct sleeplock *lk)
5173 {
5174   acquire(&lk->lk);
5175   while (lk->locked) {
5176     sleep(lk, &lk->lk);
5177   }
5178   lk->locked = 1;
5179   lk->pid = myproc()->pid;
5180   release(&lk->lk);
5181 }
5182 
5183 void
5184 releasesleep(struct sleeplock *lk)
5185 {
5186   acquire(&lk->lk);
5187   lk->locked = 0;
5188   lk->pid = 0;
5189   wakeup(lk);
5190   release(&lk->lk);
5191 }
5192 
5193 
5194 
5195 
5196 
5197 
5198 
5199 
5200 int
5201 holdingsleep(struct sleeplock *lk)
5202 {
5203   int r;
5204 
5205   acquire(&lk->lk);
5206   r = lk->locked && (lk->pid == myproc()->pid);
5207   release(&lk->lk);
5208   return r;
5209 }
5210 
5211 
5212 
5213 
5214 
5215 
5216 
5217 
5218 
5219 
5220 
5221 
5222 
5223 
5224 
5225 
5226 
5227 
5228 
5229 
5230 
5231 
5232 
5233 
5234 
5235 
5236 
5237 
5238 
5239 
5240 
5241 
5242 
5243 
5244 
5245 
5246 
5247 
5248 
5249 
5250 #include "types.h"
5251 #include "defs.h"
5252 #include "param.h"
5253 #include "spinlock.h"
5254 #include "sleeplock.h"
5255 #include "fs.h"
5256 #include "buf.h"
5257 
5258 
5259 
5260 
5261 
5262 
5263 
5264 
5265 
5266 
5267 
5268 
5269 
5270 
5271 
5272 
5273 
5274 
5275 
5276 
5277 
5278 
5279 
5280 
5281 
5282 
5283 struct logheader {
5284   int n;
5285   int block[LOGSIZE];
5286 };
5287 
5288 struct log {
5289   struct spinlock lock;
5290   int start;
5291   int size;
5292   int outstanding; 
5293   int committing;  
5294   int dev;
5295   struct logheader lh;
5296 };
5297 
5298 
5299 
5300 struct log log;
5301 
5302 static void recover_from_log(void);
5303 static void commit();
5304 
5305 void
5306 initlog(int dev)
5307 {
5308   if (sizeof(struct logheader) >= BSIZE)
5309     panic("initlog: too big logheader");
5310 
5311   struct superblock sb;
5312   initlock(&log.lock, "log");
5313   readsb(dev, &sb);
5314   log.start = sb.logstart;
5315   log.size = sb.nlog;
5316   log.dev = dev;
5317   recover_from_log();
5318 }
5319 
5320 
5321 static void
5322 install_trans(void)
5323 {
5324   int tail;
5325 
5326   for (tail = 0; tail < log.lh.n; tail++) {
5327     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
5328     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); 
5329     memmove(dbuf->data, lbuf->data, BSIZE);  
5330     bwrite(dbuf);  
5331     brelse(lbuf);
5332     brelse(dbuf);
5333   }
5334 }
5335 
5336 
5337 static void
5338 read_head(void)
5339 {
5340   struct buf *buf = bread(log.dev, log.start);
5341   struct logheader *lh = (struct logheader *) (buf->data);
5342   int i;
5343   log.lh.n = lh->n;
5344   for (i = 0; i < log.lh.n; i++) {
5345     log.lh.block[i] = lh->block[i];
5346   }
5347   brelse(buf);
5348 }
5349 
5350 
5351 
5352 
5353 static void
5354 write_head(void)
5355 {
5356   struct buf *buf = bread(log.dev, log.start);
5357   struct logheader *hb = (struct logheader *) (buf->data);
5358   int i;
5359   hb->n = log.lh.n;
5360   for (i = 0; i < log.lh.n; i++) {
5361     hb->block[i] = log.lh.block[i];
5362   }
5363   bwrite(buf);
5364   brelse(buf);
5365 }
5366 
5367 static void
5368 recover_from_log(void)
5369 {
5370   read_head();
5371   install_trans(); 
5372   log.lh.n = 0;
5373   write_head(); 
5374 }
5375 
5376 
5377 void
5378 begin_op(void)
5379 {
5380   acquire(&log.lock);
5381   while(1){
5382     if(log.committing){
5383       sleep(&log, &log.lock);
5384     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
5385       
5386       sleep(&log, &log.lock);
5387     } else {
5388       log.outstanding += 1;
5389       release(&log.lock);
5390       break;
5391     }
5392   }
5393 }
5394 
5395 
5396 
5397 
5398 
5399 
5400 
5401 
5402 void
5403 end_op(void)
5404 {
5405   int do_commit = 0;
5406 
5407   acquire(&log.lock);
5408   log.outstanding -= 1;
5409   if(log.committing)
5410     panic("log.committing");
5411   if(log.outstanding == 0){
5412     do_commit = 1;
5413     log.committing = 1;
5414   } else {
5415     
5416     
5417     
5418     wakeup(&log);
5419   }
5420   release(&log.lock);
5421 
5422   if(do_commit){
5423     
5424     
5425     commit();
5426     acquire(&log.lock);
5427     log.committing = 0;
5428     wakeup(&log);
5429     release(&log.lock);
5430   }
5431 }
5432 
5433 
5434 static void
5435 write_log(void)
5436 {
5437   int tail;
5438 
5439   for (tail = 0; tail < log.lh.n; tail++) {
5440     struct buf *to = bread(log.dev, log.start+tail+1); 
5441     struct buf *from = bread(log.dev, log.lh.block[tail]); 
5442     memmove(to->data, from->data, BSIZE);
5443     bwrite(to);  
5444     brelse(from);
5445     brelse(to);
5446   }
5447 }
5448 
5449 
5450 static void
5451 commit()
5452 {
5453   if (log.lh.n > 0) {
5454     write_log();     
5455     write_head();    
5456     install_trans(); 
5457     log.lh.n = 0;
5458     write_head();    
5459   }
5460 }
5461 
5462 
5463 
5464 
5465 
5466 
5467 
5468 
5469 
5470 
5471 void
5472 log_write(struct buf *b)
5473 {
5474   int i;
5475 
5476   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
5477     panic("too big a transaction");
5478   if (log.outstanding < 1)
5479     panic("log_write outside of trans");
5480 
5481   acquire(&log.lock);
5482   for (i = 0; i < log.lh.n; i++) {
5483     if (log.lh.block[i] == b->blockno)   
5484       break;
5485   }
5486   log.lh.block[i] = b->blockno;
5487   if (i == log.lh.n)
5488     log.lh.n++;
5489   b->flags |= B_DIRTY; 
5490   release(&log.lock);
5491 }
5492 
5493 
5494 
5495 
5496 
5497 
5498 
5499 
5500 
5501 
5502 
5503 
5504 
5505 
5506 
5507 
5508 
5509 
5510 
5511 #include "types.h"
5512 #include "defs.h"
5513 #include "param.h"
5514 #include "stat.h"
5515 #include "mmu.h"
5516 #include "proc.h"
5517 #include "spinlock.h"
5518 #include "sleeplock.h"
5519 #include "fs.h"
5520 #include "buf.h"
5521 #include "file.h"
5522 
5523 #define min(a, b) ((a) < (b) ? (a) : (b))
5524 static void itrunc(struct inode*);
5525 
5526 
5527 struct superblock sb;
5528 
5529 
5530 void
5531 readsb(int dev, struct superblock *sb)
5532 {
5533   struct buf *bp;
5534 
5535   bp = bread(dev, 1);
5536   memmove(sb, bp->data, sizeof(*sb));
5537   brelse(bp);
5538 }
5539 
5540 
5541 
5542 
5543 
5544 
5545 
5546 
5547 
5548 
5549 
5550 
5551 static void
5552 bzero(int dev, int bno)
5553 {
5554   struct buf *bp;
5555 
5556   bp = bread(dev, bno);
5557   memset(bp->data, 0, BSIZE);
5558   log_write(bp);
5559   brelse(bp);
5560 }
5561 
5562 
5563 
5564 
5565 static uint
5566 balloc(uint dev)
5567 {
5568   int b, bi, m;
5569   struct buf *bp;
5570 
5571   bp = 0;
5572   for(b = 0; b < sb.size; b += BPB){
5573     bp = bread(dev, BBLOCK(b, sb));
5574     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
5575       m = 1 << (bi % 8);
5576       if((bp->data[bi/8] & m) == 0){  
5577         bp->data[bi/8] |= m;  
5578         log_write(bp);
5579         brelse(bp);
5580         bzero(dev, b + bi);
5581         return b + bi;
5582       }
5583     }
5584     brelse(bp);
5585   }
5586   panic("balloc: out of blocks");
5587 }
5588 
5589 
5590 
5591 
5592 
5593 
5594 
5595 
5596 
5597 
5598 
5599 
5600 
5601 static void
5602 bfree(int dev, uint b)
5603 {
5604   struct buf *bp;
5605   int bi, m;
5606 
5607   readsb(dev, &sb);
5608   bp = bread(dev, BBLOCK(b, sb));
5609   bi = b % BPB;
5610   m = 1 << (bi % 8);
5611   if((bp->data[bi/8] & m) == 0)
5612     panic("freeing free block");
5613   bp->data[bi/8] &= ~m;
5614   log_write(bp);
5615   brelse(bp);
5616 }
5617 
5618 
5619 
5620 
5621 
5622 
5623 
5624 
5625 
5626 
5627 
5628 
5629 
5630 
5631 
5632 
5633 
5634 
5635 
5636 
5637 
5638 
5639 
5640 
5641 
5642 
5643 
5644 
5645 
5646 
5647 
5648 
5649 
5650 
5651 
5652 
5653 
5654 
5655 
5656 
5657 
5658 
5659 
5660 
5661 
5662 
5663 
5664 
5665 
5666 
5667 
5668 
5669 
5670 
5671 
5672 
5673 
5674 
5675 
5676 
5677 
5678 
5679 
5680 
5681 
5682 
5683 
5684 
5685 
5686 
5687 struct {
5688   struct spinlock lock;
5689   struct inode inode[NINODE];
5690 } icache;
5691 
5692 void
5693 iinit(int dev)
5694 {
5695   int i = 0;
5696 
5697   initlock(&icache.lock, "icache");
5698   for(i = 0; i < NINODE; i++) {
5699     initsleeplock(&icache.inode[i].lock, "inode");
5700   }
5701 
5702   readsb(dev, &sb);
5703   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
5704  inodestart %d bmap start %d\n", sb.size, sb.nblocks,
5705           sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
5706           sb.bmapstart);
5707 }
5708 
5709 static struct inode* iget(uint dev, uint inum);
5710 
5711 
5712 
5713 
5714 
5715 
5716 
5717 
5718 
5719 
5720 
5721 
5722 
5723 
5724 
5725 
5726 
5727 
5728 
5729 
5730 
5731 
5732 
5733 
5734 
5735 
5736 
5737 
5738 
5739 
5740 
5741 
5742 
5743 
5744 
5745 
5746 
5747 
5748 
5749 
5750 
5751 
5752 
5753 struct inode*
5754 ialloc(uint dev, short type)
5755 {
5756   int inum;
5757   struct buf *bp;
5758   struct dinode *dip;
5759 
5760   for(inum = 1; inum < sb.ninodes; inum++){
5761     bp = bread(dev, IBLOCK(inum, sb));
5762     dip = (struct dinode*)bp->data + inum%IPB;
5763     if(dip->type == 0){  
5764       memset(dip, 0, sizeof(*dip));
5765       dip->type = type;
5766       log_write(bp);   
5767       brelse(bp);
5768       return iget(dev, inum);
5769     }
5770     brelse(bp);
5771   }
5772   panic("ialloc: no inodes");
5773 }
5774 
5775 
5776 
5777 
5778 
5779 void
5780 iupdate(struct inode *ip)
5781 {
5782   struct buf *bp;
5783   struct dinode *dip;
5784 
5785   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5786   dip = (struct dinode*)bp->data + ip->inum%IPB;
5787   dip->type = ip->type;
5788   dip->major = ip->major;
5789   dip->minor = ip->minor;
5790   dip->nlink = ip->nlink;
5791   dip->size = ip->size;
5792   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
5793   log_write(bp);
5794   brelse(bp);
5795 }
5796 
5797 
5798 
5799 
5800 
5801 
5802 
5803 static struct inode*
5804 iget(uint dev, uint inum)
5805 {
5806   struct inode *ip, *empty;
5807 
5808   acquire(&icache.lock);
5809 
5810   
5811   empty = 0;
5812   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
5813     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
5814       ip->ref++;
5815       release(&icache.lock);
5816       return ip;
5817     }
5818     if(empty == 0 && ip->ref == 0)    
5819       empty = ip;
5820   }
5821 
5822   
5823   if(empty == 0)
5824     panic("iget: no inodes");
5825 
5826   ip = empty;
5827   ip->dev = dev;
5828   ip->inum = inum;
5829   ip->ref = 1;
5830   ip->valid = 0;
5831   release(&icache.lock);
5832 
5833   return ip;
5834 }
5835 
5836 
5837 
5838 struct inode*
5839 idup(struct inode *ip)
5840 {
5841   acquire(&icache.lock);
5842   ip->ref++;
5843   release(&icache.lock);
5844   return ip;
5845 }
5846 
5847 
5848 
5849 
5850 
5851 
5852 void
5853 ilock(struct inode *ip)
5854 {
5855   struct buf *bp;
5856   struct dinode *dip;
5857 
5858   if(ip == 0 || ip->ref < 1)
5859     panic("ilock");
5860 
5861   acquiresleep(&ip->lock);
5862 
5863   if(ip->valid == 0){
5864     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5865     dip = (struct dinode*)bp->data + ip->inum%IPB;
5866     ip->type = dip->type;
5867     ip->major = dip->major;
5868     ip->minor = dip->minor;
5869     ip->nlink = dip->nlink;
5870     ip->size = dip->size;
5871     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
5872     brelse(bp);
5873     ip->valid = 1;
5874     if(ip->type == 0)
5875       panic("ilock: no type");
5876   }
5877 }
5878 
5879 
5880 void
5881 iunlock(struct inode *ip)
5882 {
5883   if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
5884     panic("iunlock");
5885 
5886   releasesleep(&ip->lock);
5887 }
5888 
5889 
5890 
5891 
5892 
5893 
5894 
5895 
5896 
5897 
5898 
5899 
5900 
5901 
5902 
5903 
5904 
5905 
5906 
5907 void
5908 iput(struct inode *ip)
5909 {
5910   acquiresleep(&ip->lock);
5911   if(ip->valid && ip->nlink == 0){
5912     acquire(&icache.lock);
5913     int r = ip->ref;
5914     release(&icache.lock);
5915     if(r == 1){
5916       
5917       itrunc(ip);
5918       ip->type = 0;
5919       iupdate(ip);
5920       ip->valid = 0;
5921     }
5922   }
5923   releasesleep(&ip->lock);
5924 
5925   acquire(&icache.lock);
5926   ip->ref--;
5927   release(&icache.lock);
5928 }
5929 
5930 
5931 void
5932 iunlockput(struct inode *ip)
5933 {
5934   iunlock(ip);
5935   iput(ip);
5936 }
5937 
5938 
5939 
5940 
5941 
5942 
5943 
5944 
5945 
5946 
5947 
5948 
5949 
5950 
5951 
5952 
5953 
5954 
5955 
5956 
5957 
5958 
5959 static uint
5960 bmap(struct inode *ip, uint bn)
5961 {
5962   uint addr, *a;
5963   struct buf *bp;
5964 
5965   if(bn < NDIRECT){
5966     if((addr = ip->addrs[bn]) == 0)
5967       ip->addrs[bn] = addr = balloc(ip->dev);
5968     return addr;
5969   }
5970   bn -= NDIRECT;
5971 
5972   if(bn < NINDIRECT){
5973     
5974     if((addr = ip->addrs[NDIRECT]) == 0)
5975       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
5976     bp = bread(ip->dev, addr);
5977     a = (uint*)bp->data;
5978     if((addr = a[bn]) == 0){
5979       a[bn] = addr = balloc(ip->dev);
5980       log_write(bp);
5981     }
5982     brelse(bp);
5983     return addr;
5984   }
5985 
5986   panic("bmap: out of range");
5987 }
5988 
5989 
5990 
5991 
5992 
5993 
5994 
5995 
5996 
5997 
5998 
5999 
6000 
6001 
6002 
6003 
6004 
6005 static void
6006 itrunc(struct inode *ip)
6007 {
6008   int i, j;
6009   struct buf *bp;
6010   uint *a;
6011 
6012   for(i = 0; i < NDIRECT; i++){
6013     if(ip->addrs[i]){
6014       bfree(ip->dev, ip->addrs[i]);
6015       ip->addrs[i] = 0;
6016     }
6017   }
6018 
6019   if(ip->addrs[NDIRECT]){
6020     bp = bread(ip->dev, ip->addrs[NDIRECT]);
6021     a = (uint*)bp->data;
6022     for(j = 0; j < NINDIRECT; j++){
6023       if(a[j])
6024         bfree(ip->dev, a[j]);
6025     }
6026     brelse(bp);
6027     bfree(ip->dev, ip->addrs[NDIRECT]);
6028     ip->addrs[NDIRECT] = 0;
6029   }
6030 
6031   ip->size = 0;
6032   iupdate(ip);
6033 }
6034 
6035 
6036 
6037 void
6038 stati(struct inode *ip, struct stat *st)
6039 {
6040   st->dev = ip->dev;
6041   st->ino = ip->inum;
6042   st->type = ip->type;
6043   st->nlink = ip->nlink;
6044   st->size = ip->size;
6045 }
6046 
6047 
6048 
6049 
6050 
6051 
6052 int
6053 readi(struct inode *ip, char *dst, uint off, uint n)
6054 {
6055   uint tot, m;
6056   struct buf *bp;
6057 
6058   if(ip->type == T_DEV){
6059     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
6060       return -1;
6061     return devsw[ip->major].read(ip, dst, n);
6062   }
6063 
6064   if(off > ip->size || off + n < off)
6065     return -1;
6066   if(off + n > ip->size)
6067     n = ip->size - off;
6068 
6069   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
6070     bp = bread(ip->dev, bmap(ip, off/BSIZE));
6071     m = min(n - tot, BSIZE - off%BSIZE);
6072     memmove(dst, bp->data + off%BSIZE, m);
6073     brelse(bp);
6074   }
6075   return n;
6076 }
6077 
6078 
6079 
6080 
6081 
6082 
6083 
6084 
6085 
6086 
6087 
6088 
6089 
6090 
6091 
6092 
6093 
6094 
6095 
6096 
6097 
6098 
6099 
6100 
6101 
6102 int
6103 writei(struct inode *ip, char *src, uint off, uint n)
6104 {
6105   uint tot, m;
6106   struct buf *bp;
6107 
6108   if(ip->type == T_DEV){
6109     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
6110       return -1;
6111     return devsw[ip->major].write(ip, src, n);
6112   }
6113 
6114   if(off > ip->size || off + n < off)
6115     return -1;
6116   if(off + n > MAXFILE*BSIZE)
6117     return -1;
6118 
6119   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
6120     bp = bread(ip->dev, bmap(ip, off/BSIZE));
6121     m = min(n - tot, BSIZE - off%BSIZE);
6122     memmove(bp->data + off%BSIZE, src, m);
6123     log_write(bp);
6124     brelse(bp);
6125   }
6126 
6127   if(n > 0 && off > ip->size){
6128     ip->size = off;
6129     iupdate(ip);
6130   }
6131   return n;
6132 }
6133 
6134 
6135 
6136 
6137 
6138 
6139 
6140 
6141 
6142 
6143 
6144 
6145 
6146 
6147 
6148 
6149 
6150 
6151 
6152 int
6153 namecmp(const char *s, const char *t)
6154 {
6155   return strncmp(s, t, DIRSIZ);
6156 }
6157 
6158 
6159 
6160 struct inode*
6161 dirlookup(struct inode *dp, char *name, uint *poff)
6162 {
6163   uint off, inum;
6164   struct dirent de;
6165 
6166   if(dp->type != T_DIR)
6167     panic("dirlookup not DIR");
6168 
6169   for(off = 0; off < dp->size; off += sizeof(de)){
6170     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6171       panic("dirlookup read");
6172     if(de.inum == 0)
6173       continue;
6174     if(namecmp(name, de.name) == 0){
6175       
6176       if(poff)
6177         *poff = off;
6178       inum = de.inum;
6179       return iget(dp->dev, inum);
6180     }
6181   }
6182 
6183   return 0;
6184 }
6185 
6186 
6187 
6188 
6189 
6190 
6191 
6192 
6193 
6194 
6195 
6196 
6197 
6198 
6199 
6200 
6201 int
6202 dirlink(struct inode *dp, char *name, uint inum)
6203 {
6204   int off;
6205   struct dirent de;
6206   struct inode *ip;
6207 
6208   
6209   if((ip = dirlookup(dp, name, 0)) != 0){
6210     iput(ip);
6211     return -1;
6212   }
6213 
6214   
6215   for(off = 0; off < dp->size; off += sizeof(de)){
6216     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6217       panic("dirlink read");
6218     if(de.inum == 0)
6219       break;
6220   }
6221 
6222   strncpy(de.name, name, DIRSIZ);
6223   de.inum = inum;
6224   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6225     panic("dirlink");
6226 
6227   return 0;
6228 }
6229 
6230 
6231 
6232 
6233 
6234 
6235 
6236 
6237 
6238 
6239 
6240 
6241 
6242 
6243 
6244 
6245 
6246 
6247 
6248 
6249 
6250 
6251 
6252 
6253 
6254 
6255 
6256 
6257 
6258 
6259 
6260 
6261 
6262 
6263 
6264 static char*
6265 skipelem(char *path, char *name)
6266 {
6267   char *s;
6268   int len;
6269 
6270   while(*path == '/')
6271     path++;
6272   if(*path == 0)
6273     return 0;
6274   s = path;
6275   while(*path != '/' && *path != 0)
6276     path++;
6277   len = path - s;
6278   if(len >= DIRSIZ)
6279     memmove(name, s, DIRSIZ);
6280   else {
6281     memmove(name, s, len);
6282     name[len] = 0;
6283   }
6284   while(*path == '/')
6285     path++;
6286   return path;
6287 }
6288 
6289 
6290 
6291 
6292 
6293 
6294 
6295 
6296 
6297 
6298 
6299 
6300 
6301 
6302 
6303 
6304 static struct inode*
6305 namex(char *path, int nameiparent, char *name)
6306 {
6307   struct inode *ip, *next;
6308 
6309   if(*path == '/')
6310     ip = iget(ROOTDEV, ROOTINO);
6311   else
6312     ip = idup(myproc()->cwd);
6313 
6314   while((path = skipelem(path, name)) != 0){
6315     ilock(ip);
6316     if(ip->type != T_DIR){
6317       iunlockput(ip);
6318       return 0;
6319     }
6320     if(nameiparent && *path == '\0'){
6321       
6322       iunlock(ip);
6323       return ip;
6324     }
6325     if((next = dirlookup(ip, name, 0)) == 0){
6326       iunlockput(ip);
6327       return 0;
6328     }
6329     iunlockput(ip);
6330     ip = next;
6331   }
6332   if(nameiparent){
6333     iput(ip);
6334     return 0;
6335   }
6336   return ip;
6337 }
6338 
6339 struct inode*
6340 namei(char *path)
6341 {
6342   char name[DIRSIZ];
6343   return namex(path, 0, name);
6344 }
6345 
6346 
6347 
6348 
6349 
6350 struct inode*
6351 nameiparent(char *path, char *name)
6352 {
6353   return namex(path, 1, name);
6354 }
6355 
6356 
6357 
6358 
6359 
6360 
6361 
6362 
6363 
6364 
6365 
6366 
6367 
6368 
6369 
6370 
6371 
6372 
6373 
6374 
6375 
6376 
6377 
6378 
6379 
6380 
6381 
6382 
6383 
6384 
6385 
6386 
6387 
6388 
6389 
6390 
6391 
6392 
6393 
6394 
6395 
6396 
6397 
6398 
6399 
6400 
6401 
6402 
6403 
6404 #include "types.h"
6405 #include "defs.h"
6406 #include "param.h"
6407 #include "fs.h"
6408 #include "spinlock.h"
6409 #include "sleeplock.h"
6410 #include "file.h"
6411 
6412 struct devsw devsw[NDEV];
6413 struct {
6414   struct spinlock lock;
6415   struct file file[NFILE];
6416 } ftable;
6417 
6418 void
6419 fileinit(void)
6420 {
6421   initlock(&ftable.lock, "ftable");
6422 }
6423 
6424 
6425 struct file*
6426 filealloc(void)
6427 {
6428   struct file *f;
6429 
6430   acquire(&ftable.lock);
6431   for(f = ftable.file; f < ftable.file + NFILE; f++){
6432     if(f->ref == 0){
6433       f->ref = 1;
6434       release(&ftable.lock);
6435       return f;
6436     }
6437   }
6438   release(&ftable.lock);
6439   return 0;
6440 }
6441 
6442 
6443 
6444 
6445 
6446 
6447 
6448 
6449 
6450 
6451 struct file*
6452 filedup(struct file *f)
6453 {
6454   acquire(&ftable.lock);
6455   if(f->ref < 1)
6456     panic("filedup");
6457   f->ref++;
6458   release(&ftable.lock);
6459   return f;
6460 }
6461 
6462 
6463 void
6464 fileclose(struct file *f)
6465 {
6466   struct file ff;
6467 
6468   acquire(&ftable.lock);
6469   if(f->ref < 1)
6470     panic("fileclose");
6471   if(--f->ref > 0){
6472     release(&ftable.lock);
6473     return;
6474   }
6475   ff = *f;
6476   f->ref = 0;
6477   f->type = FD_NONE;
6478   release(&ftable.lock);
6479 
6480   if(ff.type == FD_PIPE)
6481     pipeclose(ff.pipe, ff.writable);
6482   else if(ff.type == FD_INODE){
6483     begin_op();
6484     iput(ff.ip);
6485     end_op();
6486   }
6487 }
6488 
6489 
6490 
6491 
6492 
6493 
6494 
6495 
6496 
6497 
6498 
6499 
6500 
6501 int
6502 filestat(struct file *f, struct stat *st)
6503 {
6504   if(f->type == FD_INODE){
6505     ilock(f->ip);
6506     stati(f->ip, st);
6507     iunlock(f->ip);
6508     return 0;
6509   }
6510   return -1;
6511 }
6512 
6513 
6514 int
6515 fileread(struct file *f, char *addr, int n)
6516 {
6517   int r;
6518 
6519   if(f->readable == 0)
6520     return -1;
6521   if(f->type == FD_PIPE)
6522     return piperead(f->pipe, addr, n);
6523   if(f->type == FD_INODE){
6524     ilock(f->ip);
6525     if((r = readi(f->ip, addr, f->off, n)) > 0)
6526       f->off += r;
6527     iunlock(f->ip);
6528     return r;
6529   }
6530   panic("fileread");
6531 }
6532 
6533 
6534 
6535 
6536 
6537 
6538 
6539 
6540 
6541 
6542 
6543 
6544 
6545 
6546 
6547 
6548 
6549 
6550 
6551 int
6552 filewrite(struct file *f, char *addr, int n)
6553 {
6554   int r;
6555 
6556   if(f->writable == 0)
6557     return -1;
6558   if(f->type == FD_PIPE)
6559     return pipewrite(f->pipe, addr, n);
6560   if(f->type == FD_INODE){
6561     
6562     
6563     
6564     
6565     
6566     
6567     int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
6568     int i = 0;
6569     while(i < n){
6570       int n1 = n - i;
6571       if(n1 > max)
6572         n1 = max;
6573 
6574       begin_op();
6575       ilock(f->ip);
6576       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
6577         f->off += r;
6578       iunlock(f->ip);
6579       end_op();
6580 
6581       if(r < 0)
6582         break;
6583       if(r != n1)
6584         panic("short filewrite");
6585       i += r;
6586     }
6587     return i == n ? n : -1;
6588   }
6589   panic("filewrite");
6590 }
6591 
6592 
6593 
6594 
6595 
6596 
6597 
6598 
6599 
6600 
6601 
6602 
6603 
6604 
6605 
6606 #include "types.h"
6607 #include "defs.h"
6608 #include "param.h"
6609 #include "stat.h"
6610 #include "mmu.h"
6611 #include "proc.h"
6612 #include "fs.h"
6613 #include "spinlock.h"
6614 #include "sleeplock.h"
6615 #include "file.h"
6616 #include "fcntl.h"
6617 
6618 
6619 
6620 static int
6621 argfd(int n, int *pfd, struct file **pf)
6622 {
6623   int fd;
6624   struct file *f;
6625 
6626   if(argint(n, &fd) < 0)
6627     return -1;
6628   if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
6629     return -1;
6630   if(pfd)
6631     *pfd = fd;
6632   if(pf)
6633     *pf = f;
6634   return 0;
6635 }
6636 
6637 
6638 
6639 
6640 
6641 
6642 
6643 
6644 
6645 
6646 
6647 
6648 
6649 
6650 
6651 
6652 static int
6653 fdalloc(struct file *f)
6654 {
6655   int fd;
6656   struct proc *curproc = myproc();
6657 
6658   for(fd = 0; fd < NOFILE; fd++){
6659     if(curproc->ofile[fd] == 0){
6660       curproc->ofile[fd] = f;
6661       return fd;
6662     }
6663   }
6664   return -1;
6665 }
6666 
6667 int
6668 sys_dup(void)
6669 {
6670   struct file *f;
6671   int fd;
6672 
6673   if(argfd(0, 0, &f) < 0)
6674     return -1;
6675   if((fd=fdalloc(f)) < 0)
6676     return -1;
6677   filedup(f);
6678   return fd;
6679 }
6680 
6681 int
6682 sys_read(void)
6683 {
6684   struct file *f;
6685   int n;
6686   char *p;
6687 
6688   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6689     return -1;
6690   return fileread(f, p, n);
6691 }
6692 
6693 
6694 
6695 
6696 
6697 
6698 
6699 
6700 int
6701 sys_write(void)
6702 {
6703   struct file *f;
6704   int n;
6705   char *p;
6706 
6707   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6708     return -1;
6709   return filewrite(f, p, n);
6710 }
6711 
6712 int
6713 sys_close(void)
6714 {
6715   int fd;
6716   struct file *f;
6717 
6718   if(argfd(0, &fd, &f) < 0)
6719     return -1;
6720   myproc()->ofile[fd] = 0;
6721   fileclose(f);
6722   return 0;
6723 }
6724 
6725 int
6726 sys_fstat(void)
6727 {
6728   struct file *f;
6729   struct stat *st;
6730 
6731   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
6732     return -1;
6733   return filestat(f, st);
6734 }
6735 
6736 
6737 
6738 
6739 
6740 
6741 
6742 
6743 
6744 
6745 
6746 
6747 
6748 
6749 
6750 
6751 int
6752 sys_link(void)
6753 {
6754   char name[DIRSIZ], *new, *old;
6755   struct inode *dp, *ip;
6756 
6757   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
6758     return -1;
6759 
6760   begin_op();
6761   if((ip = namei(old)) == 0){
6762     end_op();
6763     return -1;
6764   }
6765 
6766   ilock(ip);
6767   if(ip->type == T_DIR){
6768     iunlockput(ip);
6769     end_op();
6770     return -1;
6771   }
6772 
6773   ip->nlink++;
6774   iupdate(ip);
6775   iunlock(ip);
6776 
6777   if((dp = nameiparent(new, name)) == 0)
6778     goto bad;
6779   ilock(dp);
6780   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
6781     iunlockput(dp);
6782     goto bad;
6783   }
6784   iunlockput(dp);
6785   iput(ip);
6786 
6787   end_op();
6788 
6789   return 0;
6790 
6791 bad:
6792   ilock(ip);
6793   ip->nlink--;
6794   iupdate(ip);
6795   iunlockput(ip);
6796   end_op();
6797   return -1;
6798 }
6799 
6800 
6801 static int
6802 isdirempty(struct inode *dp)
6803 {
6804   int off;
6805   struct dirent de;
6806 
6807   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
6808     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6809       panic("isdirempty: readi");
6810     if(de.inum != 0)
6811       return 0;
6812   }
6813   return 1;
6814 }
6815 
6816 
6817 
6818 
6819 
6820 
6821 
6822 
6823 
6824 
6825 
6826 
6827 
6828 
6829 
6830 
6831 
6832 
6833 
6834 
6835 
6836 
6837 
6838 
6839 
6840 
6841 
6842 
6843 
6844 
6845 
6846 
6847 
6848 
6849 
6850 int
6851 sys_unlink(void)
6852 {
6853   struct inode *ip, *dp;
6854   struct dirent de;
6855   char name[DIRSIZ], *path;
6856   uint off;
6857 
6858   if(argstr(0, &path) < 0)
6859     return -1;
6860 
6861   begin_op();
6862   if((dp = nameiparent(path, name)) == 0){
6863     end_op();
6864     return -1;
6865   }
6866 
6867   ilock(dp);
6868 
6869   
6870   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
6871     goto bad;
6872 
6873   if((ip = dirlookup(dp, name, &off)) == 0)
6874     goto bad;
6875   ilock(ip);
6876 
6877   if(ip->nlink < 1)
6878     panic("unlink: nlink < 1");
6879   if(ip->type == T_DIR && !isdirempty(ip)){
6880     iunlockput(ip);
6881     goto bad;
6882   }
6883 
6884   memset(&de, 0, sizeof(de));
6885   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6886     panic("unlink: writei");
6887   if(ip->type == T_DIR){
6888     dp->nlink--;
6889     iupdate(dp);
6890   }
6891   iunlockput(dp);
6892 
6893   ip->nlink--;
6894   iupdate(ip);
6895   iunlockput(ip);
6896 
6897   end_op();
6898 
6899   return 0;
6900 bad:
6901   iunlockput(dp);
6902   end_op();
6903   return -1;
6904 }
6905 
6906 static struct inode*
6907 create(char *path, short type, short major, short minor)
6908 {
6909   uint off;
6910   struct inode *ip, *dp;
6911   char name[DIRSIZ];
6912 
6913   if((dp = nameiparent(path, name)) == 0)
6914     return 0;
6915   ilock(dp);
6916 
6917   if((ip = dirlookup(dp, name, &off)) != 0){
6918     iunlockput(dp);
6919     ilock(ip);
6920     if(type == T_FILE && ip->type == T_FILE)
6921       return ip;
6922     iunlockput(ip);
6923     return 0;
6924   }
6925 
6926   if((ip = ialloc(dp->dev, type)) == 0)
6927     panic("create: ialloc");
6928 
6929   ilock(ip);
6930   ip->major = major;
6931   ip->minor = minor;
6932   ip->nlink = 1;
6933   iupdate(ip);
6934 
6935   if(type == T_DIR){  
6936     dp->nlink++;  
6937     iupdate(dp);
6938     
6939     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
6940       panic("create dots");
6941   }
6942 
6943   if(dirlink(dp, name, ip->inum) < 0)
6944     panic("create: dirlink");
6945 
6946   iunlockput(dp);
6947 
6948   return ip;
6949 }
6950 int
6951 sys_open(void)
6952 {
6953   char *path;
6954   int fd, omode;
6955   struct file *f;
6956   struct inode *ip;
6957 
6958   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
6959     return -1;
6960 
6961   begin_op();
6962 
6963   if(omode & O_CREATE){
6964     ip = create(path, T_FILE, 0, 0);
6965     if(ip == 0){
6966       end_op();
6967       return -1;
6968     }
6969   } else {
6970     if((ip = namei(path)) == 0){
6971       end_op();
6972       return -1;
6973     }
6974     ilock(ip);
6975     if(ip->type == T_DIR && omode != O_RDONLY){
6976       iunlockput(ip);
6977       end_op();
6978       return -1;
6979     }
6980   }
6981 
6982   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
6983     if(f)
6984       fileclose(f);
6985     iunlockput(ip);
6986     end_op();
6987     return -1;
6988   }
6989   iunlock(ip);
6990   end_op();
6991 
6992   f->type = FD_INODE;
6993   f->ip = ip;
6994   f->off = 0;
6995   f->readable = !(omode & O_WRONLY);
6996   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
6997   return fd;
6998 }
6999 
7000 int
7001 sys_mkdir(void)
7002 {
7003   char *path;
7004   struct inode *ip;
7005 
7006   begin_op();
7007   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
7008     end_op();
7009     return -1;
7010   }
7011   iunlockput(ip);
7012   end_op();
7013   return 0;
7014 }
7015 
7016 int
7017 sys_mknod(void)
7018 {
7019   struct inode *ip;
7020   char *path;
7021   int major, minor;
7022 
7023   begin_op();
7024   if((argstr(0, &path)) < 0 ||
7025      argint(1, &major) < 0 ||
7026      argint(2, &minor) < 0 ||
7027      (ip = create(path, T_DEV, major, minor)) == 0){
7028     end_op();
7029     return -1;
7030   }
7031   iunlockput(ip);
7032   end_op();
7033   return 0;
7034 }
7035 
7036 
7037 
7038 
7039 
7040 
7041 
7042 
7043 
7044 
7045 
7046 
7047 
7048 
7049 
7050 int
7051 sys_chdir(void)
7052 {
7053   char *path;
7054   struct inode *ip;
7055   struct proc *curproc = myproc();
7056 
7057   begin_op();
7058   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
7059     end_op();
7060     return -1;
7061   }
7062   ilock(ip);
7063   if(ip->type != T_DIR){
7064     iunlockput(ip);
7065     end_op();
7066     return -1;
7067   }
7068   iunlock(ip);
7069   iput(curproc->cwd);
7070   end_op();
7071   curproc->cwd = ip;
7072   return 0;
7073 }
7074 
7075 int
7076 sys_exec(void)
7077 {
7078   char *path, *argv[MAXARG];
7079   int i;
7080   uint uargv, uarg;
7081 
7082   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
7083     return -1;
7084   }
7085   memset(argv, 0, sizeof(argv));
7086   for(i=0;; i++){
7087     if(i >= NELEM(argv))
7088       return -1;
7089     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
7090       return -1;
7091     if(uarg == 0){
7092       argv[i] = 0;
7093       break;
7094     }
7095     if(fetchstr(uarg, &argv[i]) < 0)
7096       return -1;
7097   }
7098   return exec(path, argv);
7099 }
7100 int
7101 sys_pipe(void)
7102 {
7103   int *fd;
7104   struct file *rf, *wf;
7105   int fd0, fd1;
7106 
7107   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
7108     return -1;
7109   if(pipealloc(&rf, &wf) < 0)
7110     return -1;
7111   fd0 = -1;
7112   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
7113     if(fd0 >= 0)
7114       myproc()->ofile[fd0] = 0;
7115     fileclose(rf);
7116     fileclose(wf);
7117     return -1;
7118   }
7119   fd[0] = fd0;
7120   fd[1] = fd1;
7121   return 0;
7122 }
7123 
7124 
7125 
7126 
7127 
7128 
7129 
7130 
7131 
7132 
7133 
7134 
7135 
7136 
7137 
7138 
7139 
7140 
7141 
7142 
7143 
7144 
7145 
7146 
7147 
7148 
7149 
7150 #include "types.h"
7151 #include "param.h"
7152 #include "memlayout.h"
7153 #include "mmu.h"
7154 #include "proc.h"
7155 #include "defs.h"
7156 #include "x86.h"
7157 #include "elf.h"
7158 
7159 int
7160 exec(char *path, char **argv)
7161 {
7162   char *s, *last;
7163   int i, off;
7164   uint argc, sz, sp, ustack[3+MAXARG+1];
7165   struct elfhdr elf;
7166   struct inode *ip;
7167   struct proghdr ph;
7168   pde_t *pgdir, *oldpgdir;
7169   struct proc *curproc = myproc();
7170 
7171   begin_op();
7172 
7173   if((ip = namei(path)) == 0){
7174     end_op();
7175     cprintf("exec: fail\n");
7176     return -1;
7177   }
7178   ilock(ip);
7179   pgdir = 0;
7180 
7181   
7182   if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
7183     goto bad;
7184   if(elf.magic != ELF_MAGIC)
7185     goto bad;
7186 
7187   if((pgdir = setupkvm()) == 0)
7188     goto bad;
7189 
7190   
7191   sz = 0;
7192   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
7193     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
7194       goto bad;
7195     if(ph.type != ELF_PROG_LOAD)
7196       continue;
7197     if(ph.memsz < ph.filesz)
7198       goto bad;
7199     if(ph.vaddr + ph.memsz < ph.vaddr)
7200       goto bad;
7201     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
7202       goto bad;
7203     if(ph.vaddr % PGSIZE != 0)
7204       goto bad;
7205     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
7206       goto bad;
7207   }
7208   iunlockput(ip);
7209   end_op();
7210   ip = 0;
7211 
7212   
7213   
7214   sz = PGROUNDUP(sz);
7215   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
7216     goto bad;
7217   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
7218   sp = sz;
7219 
7220   
7221   for(argc = 0; argv[argc]; argc++) {
7222     if(argc >= MAXARG)
7223       goto bad;
7224     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
7225     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
7226       goto bad;
7227     ustack[3+argc] = sp;
7228   }
7229   ustack[3+argc] = 0;
7230 
7231   ustack[0] = 0xffffffff;  
7232   ustack[1] = argc;
7233   ustack[2] = sp - (argc+1)*4;  
7234 
7235   sp -= (3+argc+1) * 4;
7236   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
7237     goto bad;
7238 
7239   
7240   for(last=s=path; *s; s++)
7241     if(*s == '/')
7242       last = s+1;
7243   safestrcpy(curproc->name, last, sizeof(curproc->name));
7244 
7245   
7246   oldpgdir = curproc->pgdir;
7247   curproc->pgdir = pgdir;
7248   curproc->sz = sz;
7249   curproc->tf->eip = elf.entry;  
7250   curproc->tf->esp = sp;
7251   switchuvm(curproc);
7252   freevm(oldpgdir);
7253   return 0;
7254 
7255  bad:
7256   if(pgdir)
7257     freevm(pgdir);
7258   if(ip){
7259     iunlockput(ip);
7260     end_op();
7261   }
7262   return -1;
7263 }
7264 
7265 
7266 
7267 
7268 
7269 
7270 
7271 
7272 
7273 
7274 
7275 
7276 
7277 
7278 
7279 
7280 
7281 
7282 
7283 
7284 
7285 
7286 
7287 
7288 
7289 
7290 
7291 
7292 
7293 
7294 
7295 
7296 
7297 
7298 
7299 
7300 #include "types.h"
7301 #include "defs.h"
7302 #include "param.h"
7303 #include "mmu.h"
7304 #include "proc.h"
7305 #include "fs.h"
7306 #include "spinlock.h"
7307 #include "sleeplock.h"
7308 #include "file.h"
7309 
7310 #define PIPESIZE 512
7311 
7312 struct pipe {
7313   struct spinlock lock;
7314   char data[PIPESIZE];
7315   uint nread;     
7316   uint nwrite;    
7317   int readopen;   
7318   int writeopen;  
7319 };
7320 
7321 int
7322 pipealloc(struct file **f0, struct file **f1)
7323 {
7324   struct pipe *p;
7325 
7326   p = 0;
7327   *f0 = *f1 = 0;
7328   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
7329     goto bad;
7330   if((p = (struct pipe*)kalloc()) == 0)
7331     goto bad;
7332   p->readopen = 1;
7333   p->writeopen = 1;
7334   p->nwrite = 0;
7335   p->nread = 0;
7336   initlock(&p->lock, "pipe");
7337   (*f0)->type = FD_PIPE;
7338   (*f0)->readable = 1;
7339   (*f0)->writable = 0;
7340   (*f0)->pipe = p;
7341   (*f1)->type = FD_PIPE;
7342   (*f1)->readable = 0;
7343   (*f1)->writable = 1;
7344   (*f1)->pipe = p;
7345   return 0;
7346 
7347 
7348 
7349 
7350  bad:
7351   if(p)
7352     kfree((char*)p);
7353   if(*f0)
7354     fileclose(*f0);
7355   if(*f1)
7356     fileclose(*f1);
7357   return -1;
7358 }
7359 
7360 void
7361 pipeclose(struct pipe *p, int writable)
7362 {
7363   acquire(&p->lock);
7364   if(writable){
7365     p->writeopen = 0;
7366     wakeup(&p->nread);
7367   } else {
7368     p->readopen = 0;
7369     wakeup(&p->nwrite);
7370   }
7371   if(p->readopen == 0 && p->writeopen == 0){
7372     release(&p->lock);
7373     kfree((char*)p);
7374   } else
7375     release(&p->lock);
7376 }
7377 
7378 
7379 int
7380 pipewrite(struct pipe *p, char *addr, int n)
7381 {
7382   int i;
7383 
7384   acquire(&p->lock);
7385   for(i = 0; i < n; i++){
7386     while(p->nwrite == p->nread + PIPESIZE){  
7387       if(p->readopen == 0 || myproc()->killed){
7388         release(&p->lock);
7389         return -1;
7390       }
7391       wakeup(&p->nread);
7392       sleep(&p->nwrite, &p->lock);  
7393     }
7394     p->data[p->nwrite++ % PIPESIZE] = addr[i];
7395   }
7396   wakeup(&p->nread);  
7397   release(&p->lock);
7398   return n;
7399 }
7400 int
7401 piperead(struct pipe *p, char *addr, int n)
7402 {
7403   int i;
7404 
7405   acquire(&p->lock);
7406   while(p->nread == p->nwrite && p->writeopen){  
7407     if(myproc()->killed){
7408       release(&p->lock);
7409       return -1;
7410     }
7411     sleep(&p->nread, &p->lock); 
7412   }
7413   for(i = 0; i < n; i++){  
7414     if(p->nread == p->nwrite)
7415       break;
7416     addr[i] = p->data[p->nread++ % PIPESIZE];
7417   }
7418   wakeup(&p->nwrite);  
7419   release(&p->lock);
7420   return i;
7421 }
7422 
7423 
7424 
7425 
7426 
7427 
7428 
7429 
7430 
7431 
7432 
7433 
7434 
7435 
7436 
7437 
7438 
7439 
7440 
7441 
7442 
7443 
7444 
7445 
7446 
7447 
7448 
7449 
7450 #include "types.h"
7451 #include "x86.h"
7452 
7453 void*
7454 memset(void *dst, int c, uint n)
7455 {
7456   if ((int)dst%4 == 0 && n%4 == 0){
7457     c &= 0xFF;
7458     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
7459   } else
7460     stosb(dst, c, n);
7461   return dst;
7462 }
7463 
7464 int
7465 memcmp(const void *v1, const void *v2, uint n)
7466 {
7467   const uchar *s1, *s2;
7468 
7469   s1 = v1;
7470   s2 = v2;
7471   while(n-- > 0){
7472     if(*s1 != *s2)
7473       return *s1 - *s2;
7474     s1++, s2++;
7475   }
7476 
7477   return 0;
7478 }
7479 
7480 void*
7481 memmove(void *dst, const void *src, uint n)
7482 {
7483   const char *s;
7484   char *d;
7485 
7486   s = src;
7487   d = dst;
7488   if(s < d && s + n > d){
7489     s += n;
7490     d += n;
7491     while(n-- > 0)
7492       *--d = *--s;
7493   } else
7494     while(n-- > 0)
7495       *d++ = *s++;
7496 
7497   return dst;
7498 }
7499 
7500 
7501 void*
7502 memcpy(void *dst, const void *src, uint n)
7503 {
7504   return memmove(dst, src, n);
7505 }
7506 
7507 int
7508 strncmp(const char *p, const char *q, uint n)
7509 {
7510   while(n > 0 && *p && *p == *q)
7511     n--, p++, q++;
7512   if(n == 0)
7513     return 0;
7514   return (uchar)*p - (uchar)*q;
7515 }
7516 
7517 char*
7518 strncpy(char *s, const char *t, int n)
7519 {
7520   char *os;
7521 
7522   os = s;
7523   while(n-- > 0 && (*s++ = *t++) != 0)
7524     ;
7525   while(n-- > 0)
7526     *s++ = 0;
7527   return os;
7528 }
7529 
7530 
7531 char*
7532 safestrcpy(char *s, const char *t, int n)
7533 {
7534   char *os;
7535 
7536   os = s;
7537   if(n <= 0)
7538     return os;
7539   while(--n > 0 && (*s++ = *t++) != 0)
7540     ;
7541   *s = 0;
7542   return os;
7543 }
7544 
7545 
7546 
7547 
7548 
7549 
7550 int
7551 strlen(const char *s)
7552 {
7553   int n;
7554 
7555   for(n = 0; s[n]; n++)
7556     ;
7557   return n;
7558 }
7559 
7560 
7561 
7562 
7563 
7564 
7565 
7566 
7567 
7568 
7569 
7570 
7571 
7572 
7573 
7574 
7575 
7576 
7577 
7578 
7579 
7580 
7581 
7582 
7583 
7584 
7585 
7586 
7587 
7588 
7589 
7590 
7591 
7592 
7593 
7594 
7595 
7596 
7597 
7598 
7599 
7600 
7601 
7602 struct mp {             
7603   uchar signature[4];           
7604   void *physaddr;               
7605   uchar length;                 
7606   uchar specrev;                
7607   uchar checksum;               
7608   uchar type;                   
7609   uchar imcrp;
7610   uchar reserved[3];
7611 };
7612 
7613 struct mpconf {         
7614   uchar signature[4];           
7615   ushort length;                
7616   uchar version;                
7617   uchar checksum;               
7618   uchar product[20];            
7619   uint *oemtable;               
7620   ushort oemlength;             
7621   ushort entry;                 
7622   uint *lapicaddr;              
7623   ushort xlength;               
7624   uchar xchecksum;              
7625   uchar reserved;
7626 };
7627 
7628 struct mpproc {         
7629   uchar type;                   
7630   uchar apicid;                 
7631   uchar version;                
7632   uchar flags;                  
7633     #define MPBOOT 0x02           
7634   uchar signature[4];           
7635   uint feature;                 
7636   uchar reserved[8];
7637 };
7638 
7639 struct mpioapic {       
7640   uchar type;                   
7641   uchar apicno;                 
7642   uchar version;                
7643   uchar flags;                  
7644   uint *addr;                  
7645 };
7646 
7647 
7648 
7649 
7650 
7651 #define MPPROC    0x00  
7652 #define MPBUS     0x01  
7653 #define MPIOAPIC  0x02  
7654 #define MPIOINTR  0x03  
7655 #define MPLINTR   0x04  
7656 
7657 
7658 
7659 
7660 
7661 
7662 
7663 
7664 
7665 
7666 
7667 
7668 
7669 
7670 
7671 
7672 
7673 
7674 
7675 
7676 
7677 
7678 
7679 
7680 
7681 
7682 
7683 
7684 
7685 
7686 
7687 
7688 
7689 
7690 
7691 
7692 
7693 
7694 
7695 
7696 
7697 
7698 
7699 
7700 
7701 
7702 
7703 
7704 
7705 
7706 
7707 
7708 
7709 
7710 
7711 
7712 
7713 
7714 
7715 
7716 
7717 
7718 
7719 
7720 
7721 
7722 
7723 
7724 
7725 
7726 
7727 
7728 
7729 
7730 
7731 
7732 
7733 
7734 
7735 
7736 
7737 
7738 
7739 
7740 
7741 
7742 
7743 
7744 
7745 
7746 
7747 
7748 
7749 
7750 
7751 
7752 
7753 
7754 #include "types.h"
7755 #include "defs.h"
7756 #include "param.h"
7757 #include "memlayout.h"
7758 #include "mp.h"
7759 #include "x86.h"
7760 #include "mmu.h"
7761 #include "proc.h"
7762 
7763 struct cpu cpus[NCPU];
7764 int ncpu;
7765 uchar ioapicid;
7766 
7767 static uchar
7768 sum(uchar *addr, int len)
7769 {
7770   int i, sum;
7771 
7772   sum = 0;
7773   for(i=0; i<len; i++)
7774     sum += addr[i];
7775   return sum;
7776 }
7777 
7778 
7779 static struct mp*
7780 mpsearch1(uint a, int len)
7781 {
7782   uchar *e, *p, *addr;
7783 
7784   addr = P2V(a);
7785   e = addr+len;
7786   for(p = addr; p < e; p += sizeof(struct mp))
7787     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
7788       return (struct mp*)p;
7789   return 0;
7790 }
7791 
7792 
7793 
7794 
7795 
7796 
7797 
7798 
7799 
7800 
7801 
7802 
7803 
7804 
7805 static struct mp*
7806 mpsearch(void)
7807 {
7808   uchar *bda;
7809   uint p;
7810   struct mp *mp;
7811 
7812   bda = (uchar *) P2V(0x400);
7813   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
7814     if((mp = mpsearch1(p, 1024)))
7815       return mp;
7816   } else {
7817     p = ((bda[0x14]<<8)|bda[0x13])*1024;
7818     if((mp = mpsearch1(p-1024, 1024)))
7819       return mp;
7820   }
7821   return mpsearch1(0xF0000, 0x10000);
7822 }
7823 
7824 
7825 
7826 
7827 
7828 
7829 static struct mpconf*
7830 mpconfig(struct mp **pmp)
7831 {
7832   struct mpconf *conf;
7833   struct mp *mp;
7834 
7835   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
7836     return 0;
7837   conf = (struct mpconf*) P2V((uint) mp->physaddr);
7838   if(memcmp(conf, "PCMP", 4) != 0)
7839     return 0;
7840   if(conf->version != 1 && conf->version != 4)
7841     return 0;
7842   if(sum((uchar*)conf, conf->length) != 0)
7843     return 0;
7844   *pmp = mp;
7845   return conf;
7846 }
7847 
7848 
7849 
7850 void
7851 mpinit(void)
7852 {
7853   uchar *p, *e;
7854   int ismp;
7855   struct mp *mp;
7856   struct mpconf *conf;
7857   struct mpproc *proc;
7858   struct mpioapic *ioapic;
7859 
7860   if((conf = mpconfig(&mp)) == 0)
7861     panic("Expect to run on an SMP");
7862   ismp = 1;
7863   lapic = (uint*)conf->lapicaddr;
7864   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
7865     switch(*p){
7866     case MPPROC:
7867       proc = (struct mpproc*)p;
7868       if(ncpu < NCPU) {
7869         cpus[ncpu].apicid = proc->apicid;  
7870         ncpu++;
7871       }
7872       p += sizeof(struct mpproc);
7873       continue;
7874     case MPIOAPIC:
7875       ioapic = (struct mpioapic*)p;
7876       ioapicid = ioapic->apicno;
7877       p += sizeof(struct mpioapic);
7878       continue;
7879     case MPBUS:
7880     case MPIOINTR:
7881     case MPLINTR:
7882       p += 8;
7883       continue;
7884     default:
7885       ismp = 0;
7886       break;
7887     }
7888   }
7889   if(!ismp)
7890     panic("Didn't find a suitable machine");
7891 
7892   if(mp->imcrp){
7893     
7894     
7895     outb(0x22, 0x70);   
7896     outb(0x23, inb(0x23) | 1);  
7897   }
7898 }
7899 
7900 
7901 
7902 
7903 #include "param.h"
7904 #include "types.h"
7905 #include "defs.h"
7906 #include "date.h"
7907 #include "memlayout.h"
7908 #include "traps.h"
7909 #include "mmu.h"
7910 #include "x86.h"
7911 
7912 
7913 #define ID      (0x0020/4)   
7914 #define VER     (0x0030/4)   
7915 #define TPR     (0x0080/4)   
7916 #define EOI     (0x00B0/4)   
7917 #define SVR     (0x00F0/4)   
7918   #define ENABLE     0x00000100   
7919 #define ESR     (0x0280/4)   
7920 #define ICRLO   (0x0300/4)   
7921   #define INIT       0x00000500   
7922   #define STARTUP    0x00000600   
7923   #define DELIVS     0x00001000   
7924   #define ASSERT     0x00004000   
7925   #define DEASSERT   0x00000000
7926   #define LEVEL      0x00008000   
7927   #define BCAST      0x00080000   
7928   #define BUSY       0x00001000
7929   #define FIXED      0x00000000
7930 #define ICRHI   (0x0310/4)   
7931 #define TIMER   (0x0320/4)   
7932   #define X1         0x0000000B   
7933   #define PERIODIC   0x00020000   
7934 #define PCINT   (0x0340/4)   
7935 #define LINT0   (0x0350/4)   
7936 #define LINT1   (0x0360/4)   
7937 #define ERROR   (0x0370/4)   
7938   #define MASKED     0x00010000   
7939 #define TICR    (0x0380/4)   
7940 #define TCCR    (0x0390/4)   
7941 #define TDCR    (0x03E0/4)   
7942 
7943 volatile uint *lapic;  
7944 
7945 
7946 
7947 
7948 
7949 
7950 static void
7951 lapicw(int index, int value)
7952 {
7953   lapic[index] = value;
7954   lapic[ID];  
7955 }
7956 
7957 void
7958 lapicinit(void)
7959 {
7960   if(!lapic)
7961     return;
7962 
7963   
7964   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
7965 
7966   
7967   
7968   
7969   
7970   lapicw(TDCR, X1);
7971   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
7972   lapicw(TICR, 10000000);
7973 
7974   
7975   lapicw(LINT0, MASKED);
7976   lapicw(LINT1, MASKED);
7977 
7978   
7979   
7980   if(((lapic[VER]>>16) & 0xFF) >= 4)
7981     lapicw(PCINT, MASKED);
7982 
7983   
7984   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
7985 
7986   
7987   lapicw(ESR, 0);
7988   lapicw(ESR, 0);
7989 
7990   
7991   lapicw(EOI, 0);
7992 
7993   
7994   lapicw(ICRHI, 0);
7995   lapicw(ICRLO, BCAST | INIT | LEVEL);
7996   while(lapic[ICRLO] & DELIVS)
7997     ;
7998 
7999 
8000   
8001   lapicw(TPR, 0);
8002 }
8003 
8004 int
8005 lapicid(void)
8006 {
8007   if (!lapic)
8008     return 0;
8009   return lapic[ID] >> 24;
8010 }
8011 
8012 
8013 void
8014 lapiceoi(void)
8015 {
8016   if(lapic)
8017     lapicw(EOI, 0);
8018 }
8019 
8020 
8021 
8022 void
8023 microdelay(int us)
8024 {
8025 }
8026 
8027 #define CMOS_PORT    0x70
8028 #define CMOS_RETURN  0x71
8029 
8030 
8031 
8032 void
8033 lapicstartap(uchar apicid, uint addr)
8034 {
8035   int i;
8036   ushort *wrv;
8037 
8038   
8039   
8040   
8041   outb(CMOS_PORT, 0xF);  
8042   outb(CMOS_PORT+1, 0x0A);
8043   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
8044   wrv[0] = 0;
8045   wrv[1] = addr >> 4;
8046 
8047 
8048 
8049 
8050   
8051   
8052   lapicw(ICRHI, apicid<<24);
8053   lapicw(ICRLO, INIT | LEVEL | ASSERT);
8054   microdelay(200);
8055   lapicw(ICRLO, INIT | LEVEL);
8056   microdelay(100);    
8057 
8058   
8059   
8060   
8061   
8062   
8063   for(i = 0; i < 2; i++){
8064     lapicw(ICRHI, apicid<<24);
8065     lapicw(ICRLO, STARTUP | (addr>>12));
8066     microdelay(200);
8067   }
8068 }
8069 
8070 #define CMOS_STATA   0x0a
8071 #define CMOS_STATB   0x0b
8072 #define CMOS_UIP    (1 << 7)        
8073 
8074 #define SECS    0x00
8075 #define MINS    0x02
8076 #define HOURS   0x04
8077 #define DAY     0x07
8078 #define MONTH   0x08
8079 #define YEAR    0x09
8080 
8081 static uint
8082 cmos_read(uint reg)
8083 {
8084   outb(CMOS_PORT,  reg);
8085   microdelay(200);
8086 
8087   return inb(CMOS_RETURN);
8088 }
8089 
8090 static void
8091 fill_rtcdate(struct rtcdate *r)
8092 {
8093   r->second = cmos_read(SECS);
8094   r->minute = cmos_read(MINS);
8095   r->hour   = cmos_read(HOURS);
8096   r->day    = cmos_read(DAY);
8097   r->month  = cmos_read(MONTH);
8098   r->year   = cmos_read(YEAR);
8099 }
8100 
8101 void
8102 cmostime(struct rtcdate *r)
8103 {
8104   struct rtcdate t1, t2;
8105   int sb, bcd;
8106 
8107   sb = cmos_read(CMOS_STATB);
8108 
8109   bcd = (sb & (1 << 2)) == 0;
8110 
8111   
8112   for(;;) {
8113     fill_rtcdate(&t1);
8114     if(cmos_read(CMOS_STATA) & CMOS_UIP)
8115         continue;
8116     fill_rtcdate(&t2);
8117     if(memcmp(&t1, &t2, sizeof(t1)) == 0)
8118       break;
8119   }
8120 
8121   
8122   if(bcd) {
8123 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
8124     CONV(second);
8125     CONV(minute);
8126     CONV(hour  );
8127     CONV(day   );
8128     CONV(month );
8129     CONV(year  );
8130 #undef     CONV
8131   }
8132 
8133   *r = t1;
8134   r->year += 2000;
8135 }
8136 
8137 
8138 
8139 
8140 
8141 
8142 
8143 
8144 
8145 
8146 
8147 
8148 
8149 
8150 
8151 
8152 
8153 
8154 #include "types.h"
8155 #include "defs.h"
8156 #include "traps.h"
8157 
8158 #define IOAPIC  0xFEC00000   
8159 
8160 #define REG_ID     0x00  
8161 #define REG_VER    0x01  
8162 #define REG_TABLE  0x10  
8163 
8164 
8165 
8166 
8167 
8168 
8169 #define INT_DISABLED   0x00010000  
8170 #define INT_LEVEL      0x00008000  
8171 #define INT_ACTIVELOW  0x00002000  
8172 #define INT_LOGICAL    0x00000800  
8173 
8174 volatile struct ioapic *ioapic;
8175 
8176 
8177 struct ioapic {
8178   uint reg;
8179   uint pad[3];
8180   uint data;
8181 };
8182 
8183 static uint
8184 ioapicread(int reg)
8185 {
8186   ioapic->reg = reg;
8187   return ioapic->data;
8188 }
8189 
8190 static void
8191 ioapicwrite(int reg, uint data)
8192 {
8193   ioapic->reg = reg;
8194   ioapic->data = data;
8195 }
8196 
8197 
8198 
8199 
8200 void
8201 ioapicinit(void)
8202 {
8203   int i, id, maxintr;
8204 
8205   ioapic = (volatile struct ioapic*)IOAPIC;
8206   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
8207   id = ioapicread(REG_ID) >> 24;
8208   if(id != ioapicid)
8209     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
8210 
8211   
8212   
8213   for(i = 0; i <= maxintr; i++){
8214     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
8215     ioapicwrite(REG_TABLE+2*i+1, 0);
8216   }
8217 }
8218 
8219 void
8220 ioapicenable(int irq, int cpunum)
8221 {
8222   
8223   
8224   
8225   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
8226   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
8227 }
8228 
8229 
8230 
8231 
8232 
8233 
8234 
8235 
8236 
8237 
8238 
8239 
8240 
8241 
8242 
8243 
8244 
8245 
8246 
8247 
8248 
8249 
8250 
8251 
8252 #define KBSTATP         0x64    
8253 #define KBS_DIB         0x01    
8254 #define KBDATAP         0x60    
8255 
8256 #define NO              0
8257 
8258 #define SHIFT           (1<<0)
8259 #define CTL             (1<<1)
8260 #define ALT             (1<<2)
8261 
8262 #define CAPSLOCK        (1<<3)
8263 #define NUMLOCK         (1<<4)
8264 #define SCROLLLOCK      (1<<5)
8265 
8266 #define E0ESC           (1<<6)
8267 
8268 
8269 #define KEY_HOME        0xE0
8270 #define KEY_END         0xE1
8271 #define KEY_UP          0xE2
8272 #define KEY_DN          0xE3
8273 #define KEY_LF          0xE4
8274 #define KEY_RT          0xE5
8275 #define KEY_PGUP        0xE6
8276 #define KEY_PGDN        0xE7
8277 #define KEY_INS         0xE8
8278 #define KEY_DEL         0xE9
8279 
8280 
8281 #define C(x) (x - '@')
8282 
8283 static uchar shiftcode[256] =
8284 {
8285   [0x1D] CTL,
8286   [0x2A] SHIFT,
8287   [0x36] SHIFT,
8288   [0x38] ALT,
8289   [0x9D] CTL,
8290   [0xB8] ALT
8291 };
8292 
8293 static uchar togglecode[256] =
8294 {
8295   [0x3A] CAPSLOCK,
8296   [0x45] NUMLOCK,
8297   [0x46] SCROLLLOCK
8298 };
8299 
8300 static uchar normalmap[256] =
8301 {
8302   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
8303   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
8304   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
8305   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
8306   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
8307   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
8308   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
8309   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
8310   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
8311   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
8312   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
8313   [0x9C] '\n',      
8314   [0xB5] '/',       
8315   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8316   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8317   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8318   [0x97] KEY_HOME,  [0xCF] KEY_END,
8319   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8320 };
8321 
8322 static uchar shiftmap[256] =
8323 {
8324   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
8325   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
8326   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
8327   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
8328   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
8329   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
8330   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
8331   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
8332   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
8333   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
8334   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
8335   [0x9C] '\n',      
8336   [0xB5] '/',       
8337   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8338   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8339   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8340   [0x97] KEY_HOME,  [0xCF] KEY_END,
8341   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8342 };
8343 
8344 
8345 
8346 
8347 
8348 
8349 
8350 static uchar ctlmap[256] =
8351 {
8352   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
8353   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
8354   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
8355   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
8356   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
8357   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
8358   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
8359   [0x9C] '\r',      
8360   [0xB5] C('/'),    
8361   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8362   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8363   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8364   [0x97] KEY_HOME,  [0xCF] KEY_END,
8365   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8366 };
8367 
8368 
8369 
8370 
8371 
8372 
8373 
8374 
8375 
8376 
8377 
8378 
8379 
8380 
8381 
8382 
8383 
8384 
8385 
8386 
8387 
8388 
8389 
8390 
8391 
8392 
8393 
8394 
8395 
8396 
8397 
8398 
8399 
8400 #include "types.h"
8401 #include "x86.h"
8402 #include "defs.h"
8403 #include "kbd.h"
8404 
8405 int
8406 kbdgetc(void)
8407 {
8408   static uint shift;
8409   static uchar *charcode[4] = {
8410     normalmap, shiftmap, ctlmap, ctlmap
8411   };
8412   uint st, data, c;
8413 
8414   st = inb(KBSTATP);
8415   if((st & KBS_DIB) == 0)
8416     return -1;
8417   data = inb(KBDATAP);
8418 
8419   if(data == 0xE0){
8420     shift |= E0ESC;
8421     return 0;
8422   } else if(data & 0x80){
8423     
8424     data = (shift & E0ESC ? data : data & 0x7F);
8425     shift &= ~(shiftcode[data] | E0ESC);
8426     return 0;
8427   } else if(shift & E0ESC){
8428     
8429     data |= 0x80;
8430     shift &= ~E0ESC;
8431   }
8432 
8433   shift |= shiftcode[data];
8434   shift ^= togglecode[data];
8435   c = charcode[shift & (CTL | SHIFT)][data];
8436   if(shift & CAPSLOCK){
8437     if('a' <= c && c <= 'z')
8438       c += 'A' - 'a';
8439     else if('A' <= c && c <= 'Z')
8440       c += 'a' - 'A';
8441   }
8442   return c;
8443 }
8444 
8445 void
8446 kbdintr(void)
8447 {
8448   consoleintr(kbdgetc);
8449 }
8450 
8451 
8452 
8453 
8454 #include "types.h"
8455 #include "defs.h"
8456 #include "param.h"
8457 #include "traps.h"
8458 #include "spinlock.h"
8459 #include "sleeplock.h"
8460 #include "fs.h"
8461 #include "file.h"
8462 #include "memlayout.h"
8463 #include "mmu.h"
8464 #include "proc.h"
8465 #include "x86.h"
8466 
8467 static void consputc(int);
8468 
8469 static int panicked = 0;
8470 
8471 static struct {
8472   struct spinlock lock;
8473   int locking;
8474 } cons;
8475 
8476 static void
8477 printint(int xx, int base, int sign)
8478 {
8479   static char digits[] = "0123456789abcdef";
8480   char buf[16];
8481   int i;
8482   uint x;
8483 
8484   if(sign && (sign = xx < 0))
8485     x = -xx;
8486   else
8487     x = xx;
8488 
8489   i = 0;
8490   do{
8491     buf[i++] = digits[x % base];
8492   }while((x /= base) != 0);
8493 
8494   if(sign)
8495     buf[i++] = '-';
8496 
8497   while(--i >= 0)
8498     consputc(buf[i]);
8499 }
8500 
8501 
8502 
8503 
8504 
8505 
8506 
8507 
8508 
8509 
8510 
8511 
8512 
8513 
8514 
8515 
8516 
8517 
8518 
8519 
8520 
8521 
8522 
8523 
8524 
8525 
8526 
8527 
8528 
8529 
8530 
8531 
8532 
8533 
8534 
8535 
8536 
8537 
8538 
8539 
8540 
8541 
8542 
8543 
8544 
8545 
8546 
8547 
8548 
8549 
8550 
8551 void
8552 cprintf(char *fmt, ...)
8553 {
8554   int i, c, locking;
8555   uint *argp;
8556   char *s;
8557 
8558   locking = cons.locking;
8559   if(locking)
8560     acquire(&cons.lock);
8561 
8562   if (fmt == 0)
8563     panic("null fmt");
8564 
8565   argp = (uint*)(void*)(&fmt + 1);
8566   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
8567     if(c != '%'){
8568       consputc(c);
8569       continue;
8570     }
8571     c = fmt[++i] & 0xff;
8572     if(c == 0)
8573       break;
8574     switch(c){
8575     case 'd':
8576       printint(*argp++, 10, 1);
8577       break;
8578     case 'x':
8579     case 'p':
8580       printint(*argp++, 16, 0);
8581       break;
8582     case 's':
8583       if((s = (char*)*argp++) == 0)
8584         s = "(null)";
8585       for(; *s; s++)
8586         consputc(*s);
8587       break;
8588     case '%':
8589       consputc('%');
8590       break;
8591     default:
8592       
8593       consputc('%');
8594       consputc(c);
8595       break;
8596     }
8597   }
8598 
8599 
8600   if(locking)
8601     release(&cons.lock);
8602 }
8603 
8604 void
8605 panic(char *s)
8606 {
8607   int i;
8608   uint pcs[10];
8609 
8610   cli();
8611   cons.locking = 0;
8612   
8613   cprintf("lapicid %d: panic: ", lapicid());
8614   cprintf(s);
8615   cprintf("\n");
8616   getcallerpcs(&s, pcs);
8617   for(i=0; i<10; i++)
8618     cprintf(" %p", pcs[i]);
8619   panicked = 1; 
8620   for(;;)
8621     ;
8622 }
8623 
8624 
8625 
8626 
8627 
8628 
8629 
8630 
8631 
8632 
8633 
8634 
8635 
8636 
8637 
8638 
8639 
8640 
8641 
8642 
8643 
8644 
8645 
8646 
8647 
8648 
8649 
8650 #define BACKSPACE 0x100
8651 #define CRTPORT 0x3d4
8652 static ushort *crt = (ushort*)P2V(0xb8000);  
8653 
8654 static void
8655 cgaputc(int c)
8656 {
8657   int pos;
8658 
8659   
8660   outb(CRTPORT, 14);
8661   pos = inb(CRTPORT+1) << 8;
8662   outb(CRTPORT, 15);
8663   pos |= inb(CRTPORT+1);
8664 
8665   if(c == '\n')
8666     pos += 80 - pos%80;
8667   else if(c == BACKSPACE){
8668     if(pos > 0) --pos;
8669   } else
8670     crt[pos++] = (c&0xff) | 0x0700;  
8671 
8672   if(pos < 0 || pos > 25*80)
8673     panic("pos under/overflow");
8674 
8675   if((pos/80) >= 24){  
8676     memmove(crt, crt+80, sizeof(crt[0])*23*80);
8677     pos -= 80;
8678     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
8679   }
8680 
8681   outb(CRTPORT, 14);
8682   outb(CRTPORT+1, pos>>8);
8683   outb(CRTPORT, 15);
8684   outb(CRTPORT+1, pos);
8685   crt[pos] = ' ' | 0x0700;
8686 }
8687 
8688 
8689 
8690 
8691 
8692 
8693 
8694 
8695 
8696 
8697 
8698 
8699 
8700 void
8701 consputc(int c)
8702 {
8703   if(panicked){
8704     cli();
8705     for(;;)
8706       ;
8707   }
8708 
8709   if(c == BACKSPACE){
8710     uartputc('\b'); uartputc(' '); uartputc('\b');
8711   } else
8712     uartputc(c);
8713   cgaputc(c);
8714 }
8715 
8716 #define INPUT_BUF 128
8717 struct {
8718   char buf[INPUT_BUF];
8719   uint r;  
8720   uint w;  
8721   uint e;  
8722 } input;
8723 
8724 #define C(x)  ((x)-'@')  
8725 
8726 void
8727 consoleintr(int (*getc)(void))
8728 {
8729   int c, doprocdump = 0;
8730 
8731   acquire(&cons.lock);
8732   while((c = getc()) >= 0){
8733     switch(c){
8734     case C('P'):  
8735       
8736       doprocdump = 1;
8737       break;
8738     case C('U'):  
8739       while(input.e != input.w &&
8740             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
8741         input.e--;
8742         consputc(BACKSPACE);
8743       }
8744       break;
8745     case C('H'): case '\x7f':  
8746       if(input.e != input.w){
8747         input.e--;
8748         consputc(BACKSPACE);
8749       }
8750       break;
8751     default:
8752       if(c != 0 && input.e-input.r < INPUT_BUF){
8753         c = (c == '\r') ? '\n' : c;
8754         input.buf[input.e++ % INPUT_BUF] = c;
8755         consputc(c);
8756         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
8757           input.w = input.e;
8758           wakeup(&input.r);
8759         }
8760       }
8761       break;
8762     }
8763   }
8764   release(&cons.lock);
8765   if(doprocdump) {
8766     procdump();  
8767   }
8768 }
8769 
8770 int
8771 consoleread(struct inode *ip, char *dst, int n)
8772 {
8773   uint target;
8774   int c;
8775 
8776   iunlock(ip);
8777   target = n;
8778   acquire(&cons.lock);
8779   while(n > 0){
8780     while(input.r == input.w){
8781       if(myproc()->killed){
8782         release(&cons.lock);
8783         ilock(ip);
8784         return -1;
8785       }
8786       sleep(&input.r, &cons.lock);
8787     }
8788     c = input.buf[input.r++ % INPUT_BUF];
8789     if(c == C('D')){  
8790       if(n < target){
8791         
8792         
8793         input.r--;
8794       }
8795       break;
8796     }
8797     *dst++ = c;
8798     --n;
8799     if(c == '\n')
8800       break;
8801   }
8802   release(&cons.lock);
8803   ilock(ip);
8804 
8805   return target - n;
8806 }
8807 
8808 int
8809 consolewrite(struct inode *ip, char *buf, int n)
8810 {
8811   int i;
8812 
8813   iunlock(ip);
8814   acquire(&cons.lock);
8815   for(i = 0; i < n; i++)
8816     consputc(buf[i] & 0xff);
8817   release(&cons.lock);
8818   ilock(ip);
8819 
8820   return n;
8821 }
8822 
8823 void
8824 consoleinit(void)
8825 {
8826   initlock(&cons.lock, "console");
8827 
8828   devsw[CONSOLE].write = consolewrite;
8829   devsw[CONSOLE].read = consoleread;
8830   cons.locking = 1;
8831 
8832   ioapicenable(IRQ_KBD, 0);
8833 }
8834 
8835 
8836 
8837 
8838 
8839 
8840 
8841 
8842 
8843 
8844 
8845 
8846 
8847 
8848 
8849 
8850 
8851 
8852 #include "types.h"
8853 #include "defs.h"
8854 #include "param.h"
8855 #include "traps.h"
8856 #include "spinlock.h"
8857 #include "sleeplock.h"
8858 #include "fs.h"
8859 #include "file.h"
8860 #include "mmu.h"
8861 #include "proc.h"
8862 #include "x86.h"
8863 
8864 #define COM1    0x3f8
8865 
8866 static int uart;    
8867 
8868 void
8869 uartinit(void)
8870 {
8871   char *p;
8872 
8873   
8874   outb(COM1+2, 0);
8875 
8876   
8877   outb(COM1+3, 0x80);    
8878   outb(COM1+0, 115200/9600);
8879   outb(COM1+1, 0);
8880   outb(COM1+3, 0x03);    
8881   outb(COM1+4, 0);
8882   outb(COM1+1, 0x01);    
8883 
8884   
8885   if(inb(COM1+5) == 0xFF)
8886     return;
8887   uart = 1;
8888 
8889   
8890   
8891   inb(COM1+2);
8892   inb(COM1+0);
8893   ioapicenable(IRQ_COM1, 0);
8894 
8895   
8896   for(p="xv6...\n"; *p; p++)
8897     uartputc(*p);
8898 }
8899 
8900 void
8901 uartputc(int c)
8902 {
8903   int i;
8904 
8905   if(!uart)
8906     return;
8907   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
8908     microdelay(10);
8909   outb(COM1+0, c);
8910 }
8911 
8912 static int
8913 uartgetc(void)
8914 {
8915   if(!uart)
8916     return -1;
8917   if(!(inb(COM1+5) & 0x01))
8918     return -1;
8919   return inb(COM1+0);
8920 }
8921 
8922 void
8923 uartintr(void)
8924 {
8925   consoleintr(uartgetc);
8926 }
8927 
8928 
8929 
8930 
8931 
8932 
8933 
8934 
8935 
8936 
8937 
8938 
8939 
8940 
8941 
8942 
8943 
8944 
8945 
8946 
8947 
8948 
8949 
8950 
8951 
8952 
8953 
8954 
8955 
8956 
8957 
8958 .globl start
8959 start:
8960   pushl $argv
8961   pushl $init
8962   pushl $0  
8963   movl $SYS_exec, %eax
8964   int $T_SYSCALL
8965 
8966 
8967 exit:
8968   movl $SYS_exit, %eax
8969   int $T_SYSCALL
8970   jmp exit
8971 
8972 
8973 init:
8974   .string "/init\0"
8975 
8976 
8977 .p2align 2
8978 argv:
8979   .long init
8980   .long 0
8981 
8982 
8983 
8984 
8985 
8986 
8987 
8988 
8989 
8990 
8991 
8992 
8993 
8994 
8995 
8996 
8997 
8998 
8999 
9000 
9001 
9002 
9003 
9004   .globl name; \
9005   name: \
9006     movl $SYS_ 
9007     int $T_SYSCALL; \
9008     ret
9009 
9010 SYSCALL(fork)
9011 SYSCALL(exit)
9012 SYSCALL(wait)
9013 SYSCALL(pipe)
9014 SYSCALL(read)
9015 SYSCALL(write)
9016 SYSCALL(close)
9017 SYSCALL(kill)
9018 SYSCALL(exec)
9019 SYSCALL(open)
9020 SYSCALL(mknod)
9021 SYSCALL(unlink)
9022 SYSCALL(fstat)
9023 SYSCALL(link)
9024 SYSCALL(mkdir)
9025 SYSCALL(chdir)
9026 SYSCALL(dup)
9027 SYSCALL(getpid)
9028 SYSCALL(sbrk)
9029 SYSCALL(sleep)
9030 SYSCALL(uptime)
9031 SYSCALL(halt)
9032 SYSCALL(getnice)
9033 SYSCALL(setnice)
9034 SYSCALL(ps)
9035 SYSCALL(thread_create)
9036 SYSCALL(thread_exit)
9037 SYSCALL(thread_join)
9038 SYSCALL(gettid)
9039 SYSCALL(mutex_init)
9040 SYSCALL(mutex_lock)
9041 SYSCALL(mutex_unlock)
9042 SYSCALL(cond_init)
9043 SYSCALL(cond_wait)
9044 SYSCALL(cond_signal)
9045 
9046 
9047 
9048 
9049 
9050 
9051 
9052 #include "types.h"
9053 #include "stat.h"
9054 #include "user.h"
9055 #include "fcntl.h"
9056 
9057 char *argv[] = { "sh", 0 };
9058 
9059 int
9060 main(void)
9061 {
9062   int pid, wpid;
9063 
9064   if(open("console", O_RDWR) < 0){
9065     mknod("console", 1, 1);
9066     open("console", O_RDWR);
9067   }
9068   dup(0);  
9069   dup(0);  
9070   for(;;){
9071     printf(1, "init: starting sh\n");
9072 	printf(1, "Student ID: 2016312029\n");
9073 	printf(1, "Name: Hyeongjun Park\n");
9074     pid = fork();
9075     if(pid < 0){
9076       printf(1, "init: fork failed\n");
9077       exit();
9078     }
9079     if(pid == 0){
9080       exec("sh", argv);
9081       printf(1, "init: exec sh failed\n");
9082       exit();
9083     }
9084     while((wpid=wait()) >= 0 && wpid != pid)
9085       printf(1, "zombie!\n");
9086   }
9087 }
9088 
9089 
9090 
9091 
9092 
9093 
9094 
9095 
9096 
9097 
9098 
9099 
9100 
9101 
9102 #include "types.h"
9103 #include "user.h"
9104 #include "fcntl.h"
9105 
9106 
9107 #define EXEC  1
9108 #define REDIR 2
9109 #define PIPE  3
9110 #define LIST  4
9111 #define BACK  5
9112 
9113 #define MAXARGS 10
9114 
9115 struct cmd {
9116   int type;
9117 };
9118 
9119 struct execcmd {
9120   int type;
9121   char *argv[MAXARGS];
9122   char *eargv[MAXARGS];
9123 };
9124 
9125 struct redircmd {
9126   int type;
9127   struct cmd *cmd;
9128   char *file;
9129   char *efile;
9130   int mode;
9131   int fd;
9132 };
9133 
9134 struct pipecmd {
9135   int type;
9136   struct cmd *left;
9137   struct cmd *right;
9138 };
9139 
9140 struct listcmd {
9141   int type;
9142   struct cmd *left;
9143   struct cmd *right;
9144 };
9145 
9146 struct backcmd {
9147   int type;
9148   struct cmd *cmd;
9149 };
9150 int fork1(void);  
9151 void panic(char*);
9152 struct cmd *parsecmd(char*);
9153 
9154 
9155 void
9156 runcmd(struct cmd *cmd)
9157 {
9158   int p[2];
9159   struct backcmd *bcmd;
9160   struct execcmd *ecmd;
9161   struct listcmd *lcmd;
9162   struct pipecmd *pcmd;
9163   struct redircmd *rcmd;
9164 
9165   if(cmd == 0)
9166     exit();
9167 
9168   switch(cmd->type){
9169   default:
9170     panic("runcmd");
9171 
9172   case EXEC:
9173     ecmd = (struct execcmd*)cmd;
9174     if(ecmd->argv[0] == 0)
9175       exit();
9176     exec(ecmd->argv[0], ecmd->argv);
9177     printf(2, "exec %s failed\n", ecmd->argv[0]);
9178     break;
9179 
9180   case REDIR:
9181     rcmd = (struct redircmd*)cmd;
9182     close(rcmd->fd);
9183     if(open(rcmd->file, rcmd->mode) < 0){
9184       printf(2, "open %s failed\n", rcmd->file);
9185       exit();
9186     }
9187     runcmd(rcmd->cmd);
9188     break;
9189 
9190   case LIST:
9191     lcmd = (struct listcmd*)cmd;
9192     if(fork1() == 0)
9193       runcmd(lcmd->left);
9194     wait();
9195     runcmd(lcmd->right);
9196     break;
9197 
9198 
9199 
9200   case PIPE:
9201     pcmd = (struct pipecmd*)cmd;
9202     if(pipe(p) < 0)
9203       panic("pipe");
9204     if(fork1() == 0){
9205       close(1);
9206       dup(p[1]);
9207       close(p[0]);
9208       close(p[1]);
9209       runcmd(pcmd->left);
9210     }
9211     if(fork1() == 0){
9212       close(0);
9213       dup(p[0]);
9214       close(p[0]);
9215       close(p[1]);
9216       runcmd(pcmd->right);
9217     }
9218     close(p[0]);
9219     close(p[1]);
9220     wait();
9221     wait();
9222     break;
9223 
9224   case BACK:
9225     bcmd = (struct backcmd*)cmd;
9226     if(fork1() == 0)
9227       runcmd(bcmd->cmd);
9228     break;
9229   }
9230   exit();
9231 }
9232 
9233 int
9234 getcmd(char *buf, int nbuf)
9235 {
9236   printf(2, "$ ");
9237   memset(buf, 0, nbuf);
9238   gets(buf, nbuf);
9239   if(buf[0] == 0) 
9240     return -1;
9241   return 0;
9242 }
9243 
9244 
9245 
9246 
9247 
9248 
9249 
9250 int
9251 main(void)
9252 {
9253   static char buf[100];
9254   int fd;
9255 
9256   
9257   while((fd = open("console", O_RDWR)) >= 0){
9258     if(fd >= 3){
9259       close(fd);
9260       break;
9261     }
9262   }
9263 
9264   
9265   while(getcmd(buf, sizeof(buf)) >= 0){
9266     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
9267       
9268       buf[strlen(buf)-1] = 0;  
9269       if(chdir(buf+3) < 0)
9270         printf(2, "cannot cd %s\n", buf+3);
9271       continue;
9272     }
9273     if(fork1() == 0)
9274       runcmd(parsecmd(buf));
9275     wait();
9276   }
9277   exit();
9278 }
9279 
9280 void
9281 panic(char *s)
9282 {
9283   printf(2, "%s\n", s);
9284   exit();
9285 }
9286 
9287 int
9288 fork1(void)
9289 {
9290   int pid;
9291 
9292   pid = fork();
9293   if(pid == -1)
9294     panic("fork");
9295   return pid;
9296 }
9297 
9298 
9299 
9300 
9301 
9302 struct cmd*
9303 execcmd(void)
9304 {
9305   struct execcmd *cmd;
9306 
9307   cmd = malloc(sizeof(*cmd));
9308   memset(cmd, 0, sizeof(*cmd));
9309   cmd->type = EXEC;
9310   return (struct cmd*)cmd;
9311 }
9312 
9313 struct cmd*
9314 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
9315 {
9316   struct redircmd *cmd;
9317 
9318   cmd = malloc(sizeof(*cmd));
9319   memset(cmd, 0, sizeof(*cmd));
9320   cmd->type = REDIR;
9321   cmd->cmd = subcmd;
9322   cmd->file = file;
9323   cmd->efile = efile;
9324   cmd->mode = mode;
9325   cmd->fd = fd;
9326   return (struct cmd*)cmd;
9327 }
9328 
9329 struct cmd*
9330 pipecmd(struct cmd *left, struct cmd *right)
9331 {
9332   struct pipecmd *cmd;
9333 
9334   cmd = malloc(sizeof(*cmd));
9335   memset(cmd, 0, sizeof(*cmd));
9336   cmd->type = PIPE;
9337   cmd->left = left;
9338   cmd->right = right;
9339   return (struct cmd*)cmd;
9340 }
9341 
9342 
9343 
9344 
9345 
9346 
9347 
9348 
9349 
9350 struct cmd*
9351 listcmd(struct cmd *left, struct cmd *right)
9352 {
9353   struct listcmd *cmd;
9354 
9355   cmd = malloc(sizeof(*cmd));
9356   memset(cmd, 0, sizeof(*cmd));
9357   cmd->type = LIST;
9358   cmd->left = left;
9359   cmd->right = right;
9360   return (struct cmd*)cmd;
9361 }
9362 
9363 struct cmd*
9364 backcmd(struct cmd *subcmd)
9365 {
9366   struct backcmd *cmd;
9367 
9368   cmd = malloc(sizeof(*cmd));
9369   memset(cmd, 0, sizeof(*cmd));
9370   cmd->type = BACK;
9371   cmd->cmd = subcmd;
9372   return (struct cmd*)cmd;
9373 }
9374 
9375 
9376 
9377 
9378 
9379 
9380 
9381 
9382 
9383 
9384 
9385 
9386 
9387 
9388 
9389 
9390 
9391 
9392 
9393 
9394 
9395 
9396 
9397 
9398 
9399 
9400 
9401 
9402 char whitespace[] = " \t\r\n\v";
9403 char symbols[] = "<|>&;()";
9404 
9405 int
9406 gettoken(char **ps, char *es, char **q, char **eq)
9407 {
9408   char *s;
9409   int ret;
9410 
9411   s = *ps;
9412   while(s < es && strchr(whitespace, *s))
9413     s++;
9414   if(q)
9415     *q = s;
9416   ret = *s;
9417   switch(*s){
9418   case 0:
9419     break;
9420   case '|':
9421   case '(':
9422   case ')':
9423   case ';':
9424   case '&':
9425   case '<':
9426     s++;
9427     break;
9428   case '>':
9429     s++;
9430     if(*s == '>'){
9431       ret = '+';
9432       s++;
9433     }
9434     break;
9435   default:
9436     ret = 'a';
9437     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
9438       s++;
9439     break;
9440   }
9441   if(eq)
9442     *eq = s;
9443 
9444   while(s < es && strchr(whitespace, *s))
9445     s++;
9446   *ps = s;
9447   return ret;
9448 }
9449 
9450 int
9451 peek(char **ps, char *es, char *toks)
9452 {
9453   char *s;
9454 
9455   s = *ps;
9456   while(s < es && strchr(whitespace, *s))
9457     s++;
9458   *ps = s;
9459   return *s && strchr(toks, *s);
9460 }
9461 
9462 struct cmd *parseline(char**, char*);
9463 struct cmd *parsepipe(char**, char*);
9464 struct cmd *parseexec(char**, char*);
9465 struct cmd *nulterminate(struct cmd*);
9466 
9467 struct cmd*
9468 parsecmd(char *s)
9469 {
9470   char *es;
9471   struct cmd *cmd;
9472 
9473   es = s + strlen(s);
9474   cmd = parseline(&s, es);
9475   peek(&s, es, "");
9476   if(s != es){
9477     printf(2, "leftovers: %s\n", s);
9478     panic("syntax");
9479   }
9480   nulterminate(cmd);
9481   return cmd;
9482 }
9483 
9484 struct cmd*
9485 parseline(char **ps, char *es)
9486 {
9487   struct cmd *cmd;
9488 
9489   cmd = parsepipe(ps, es);
9490   while(peek(ps, es, "&")){
9491     gettoken(ps, es, 0, 0);
9492     cmd = backcmd(cmd);
9493   }
9494   if(peek(ps, es, ";")){
9495     gettoken(ps, es, 0, 0);
9496     cmd = listcmd(cmd, parseline(ps, es));
9497   }
9498   return cmd;
9499 }
9500 struct cmd*
9501 parsepipe(char **ps, char *es)
9502 {
9503   struct cmd *cmd;
9504 
9505   cmd = parseexec(ps, es);
9506   if(peek(ps, es, "|")){
9507     gettoken(ps, es, 0, 0);
9508     cmd = pipecmd(cmd, parsepipe(ps, es));
9509   }
9510   return cmd;
9511 }
9512 
9513 struct cmd*
9514 parseredirs(struct cmd *cmd, char **ps, char *es)
9515 {
9516   int tok;
9517   char *q, *eq;
9518 
9519   while(peek(ps, es, "<>")){
9520     tok = gettoken(ps, es, 0, 0);
9521     if(gettoken(ps, es, &q, &eq) != 'a')
9522       panic("missing file for redirection");
9523     switch(tok){
9524     case '<':
9525       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
9526       break;
9527     case '>':
9528       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9529       break;
9530     case '+':  
9531       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9532       break;
9533     }
9534   }
9535   return cmd;
9536 }
9537 
9538 
9539 
9540 
9541 
9542 
9543 
9544 
9545 
9546 
9547 
9548 
9549 
9550 struct cmd*
9551 parseblock(char **ps, char *es)
9552 {
9553   struct cmd *cmd;
9554 
9555   if(!peek(ps, es, "("))
9556     panic("parseblock");
9557   gettoken(ps, es, 0, 0);
9558   cmd = parseline(ps, es);
9559   if(!peek(ps, es, ")"))
9560     panic("syntax - missing )");
9561   gettoken(ps, es, 0, 0);
9562   cmd = parseredirs(cmd, ps, es);
9563   return cmd;
9564 }
9565 
9566 struct cmd*
9567 parseexec(char **ps, char *es)
9568 {
9569   char *q, *eq;
9570   int tok, argc;
9571   struct execcmd *cmd;
9572   struct cmd *ret;
9573 
9574   if(peek(ps, es, "("))
9575     return parseblock(ps, es);
9576 
9577   ret = execcmd();
9578   cmd = (struct execcmd*)ret;
9579 
9580   argc = 0;
9581   ret = parseredirs(ret, ps, es);
9582   while(!peek(ps, es, "|)&;")){
9583     if((tok=gettoken(ps, es, &q, &eq)) == 0)
9584       break;
9585     if(tok != 'a')
9586       panic("syntax");
9587     cmd->argv[argc] = q;
9588     cmd->eargv[argc] = eq;
9589     argc++;
9590     if(argc >= MAXARGS)
9591       panic("too many args");
9592     ret = parseredirs(ret, ps, es);
9593   }
9594   cmd->argv[argc] = 0;
9595   cmd->eargv[argc] = 0;
9596   return ret;
9597 }
9598 
9599 
9600 
9601 struct cmd*
9602 nulterminate(struct cmd *cmd)
9603 {
9604   int i;
9605   struct backcmd *bcmd;
9606   struct execcmd *ecmd;
9607   struct listcmd *lcmd;
9608   struct pipecmd *pcmd;
9609   struct redircmd *rcmd;
9610 
9611   if(cmd == 0)
9612     return 0;
9613 
9614   switch(cmd->type){
9615   case EXEC:
9616     ecmd = (struct execcmd*)cmd;
9617     for(i=0; ecmd->argv[i]; i++)
9618       *ecmd->eargv[i] = 0;
9619     break;
9620 
9621   case REDIR:
9622     rcmd = (struct redircmd*)cmd;
9623     nulterminate(rcmd->cmd);
9624     *rcmd->efile = 0;
9625     break;
9626 
9627   case PIPE:
9628     pcmd = (struct pipecmd*)cmd;
9629     nulterminate(pcmd->left);
9630     nulterminate(pcmd->right);
9631     break;
9632 
9633   case LIST:
9634     lcmd = (struct listcmd*)cmd;
9635     nulterminate(lcmd->left);
9636     nulterminate(lcmd->right);
9637     break;
9638 
9639   case BACK:
9640     bcmd = (struct backcmd*)cmd;
9641     nulterminate(bcmd->cmd);
9642     break;
9643   }
9644   return cmd;
9645 }
9646 
9647 
9648 
9649 
9650 
9651 
9652 
9653 
9654 
9655 
9656 
9657 
9658 
9659 .code16                       
9660 .globl start
9661 start:
9662   cli                         
9663 
9664   
9665   xorw    %ax,%ax             
9666   movw    %ax,%ds             
9667   movw    %ax,%es             
9668   movw    %ax,%ss             
9669 
9670   
9671   
9672 seta20.1:
9673   inb     $0x64,%al               
9674   testb   $0x2,%al
9675   jnz     seta20.1
9676 
9677   movb    $0xd1,%al               
9678   outb    %al,$0x64
9679 
9680 seta20.2:
9681   inb     $0x64,%al               
9682   testb   $0x2,%al
9683   jnz     seta20.2
9684 
9685   movb    $0xdf,%al               
9686   outb    %al,$0x60
9687 
9688   
9689   
9690   
9691   lgdt    gdtdesc
9692   movl    %cr0, %eax
9693   orl     $CR0_PE, %eax
9694   movl    %eax, %cr0
9695 
9696 
9697 
9698 
9699 
9700   
9701   
9702   
9703   ljmp    $(SEG_KCODE<<3), $start32
9704 
9705 .code32  
9706 start32:
9707   
9708   movw    $(SEG_KDATA<<3), %ax    
9709   movw    %ax, %ds                
9710   movw    %ax, %es                
9711   movw    %ax, %ss                
9712   movw    $0, %ax                 
9713   movw    %ax, %fs                
9714   movw    %ax, %gs                
9715 
9716   
9717   movl    $start, %esp
9718   call    bootmain
9719 
9720   
9721   
9722   movw    $0x8a00, %ax            
9723   movw    %ax, %dx
9724   outw    %ax, %dx
9725   movw    $0x8ae0, %ax            
9726   outw    %ax, %dx
9727 spin:
9728   jmp     spin
9729 
9730 
9731 .p2align 2                                
9732 gdt:
9733   SEG_NULLASM                             
9734   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
9735   SEG_ASM(STA_W, 0x0, 0xffffffff)         
9736 
9737 gdtdesc:
9738   .word   (gdtdesc - gdt - 1)             
9739   .long   gdt                             
9740 
9741 
9742 
9743 
9744 
9745 
9746 
9747 
9748 
9749 
9750 
9751 
9752 
9753 
9754 
9755 
9756 
9757 #include "types.h"
9758 #include "elf.h"
9759 #include "x86.h"
9760 #include "memlayout.h"
9761 
9762 #define SECTSIZE  512
9763 
9764 void readseg(uchar*, uint, uint);
9765 
9766 void
9767 bootmain(void)
9768 {
9769   struct elfhdr *elf;
9770   struct proghdr *ph, *eph;
9771   void (*entry)(void);
9772   uchar* pa;
9773 
9774   elf = (struct elfhdr*)0x10000;  
9775 
9776   
9777   readseg((uchar*)elf, 4096, 0);
9778 
9779   
9780   if(elf->magic != ELF_MAGIC)
9781     return;  
9782 
9783   
9784   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
9785   eph = ph + elf->phnum;
9786   for(; ph < eph; ph++){
9787     pa = (uchar*)ph->paddr;
9788     readseg(pa, ph->filesz, ph->off);
9789     if(ph->memsz > ph->filesz)
9790       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
9791   }
9792 
9793   
9794   
9795   entry = (void(*)(void))(elf->entry);
9796   entry();
9797 }
9798 
9799 
9800 void
9801 waitdisk(void)
9802 {
9803   
9804   while((inb(0x1F7) & 0xC0) != 0x40)
9805     ;
9806 }
9807 
9808 
9809 void
9810 readsect(void *dst, uint offset)
9811 {
9812   
9813   waitdisk();
9814   outb(0x1F2, 1);   
9815   outb(0x1F3, offset);
9816   outb(0x1F4, offset >> 8);
9817   outb(0x1F5, offset >> 16);
9818   outb(0x1F6, (offset >> 24) | 0xE0);
9819   outb(0x1F7, 0x20);  
9820 
9821   
9822   waitdisk();
9823   insl(0x1F0, dst, SECTSIZE/4);
9824 }
9825 
9826 
9827 
9828 void
9829 readseg(uchar* pa, uint count, uint offset)
9830 {
9831   uchar* epa;
9832 
9833   epa = pa + count;
9834 
9835   
9836   pa -= offset % SECTSIZE;
9837 
9838   
9839   offset = (offset / SECTSIZE) + 1;
9840 
9841   
9842   
9843   
9844   for(; pa < epa; pa += SECTSIZE, offset++)
9845     readsect(pa, offset);
9846 }
9847 
9848 
9849 
9850 /* Simple linker script for the JOS kernel.
9851    See the GNU ld 'info' manual ("info ld") to learn the syntax. */
9852 
9853 OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
9854 OUTPUT_ARCH(i386)
9855 ENTRY(_start)
9856 
9857 SECTIONS
9858 {
9859 	/* Link the kernel at this address: "." means the current address */
9860         /* Must be equal to KERNLINK */
9861 	. = 0x80100000;
9862 
9863 	.text : AT(0x100000) {
9864 		*(.text .stub .text.* .gnu.linkonce.t.*)
9865 	}
9866 
9867 	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
9868 
9869 	.rodata : {
9870 		*(.rodata .rodata.* .gnu.linkonce.r.*)
9871 	}
9872 
9873 	/* Include debugging information in kernel memory */
9874 	.stab : {
9875 		PROVIDE(__STAB_BEGIN__ = .);
9876 		*(.stab);
9877 		PROVIDE(__STAB_END__ = .);
9878 		BYTE(0)		/* Force the linker to allocate space
9879 				   for this section */
9880 	}
9881 
9882 	.stabstr : {
9883 		PROVIDE(__STABSTR_BEGIN__ = .);
9884 		*(.stabstr);
9885 		PROVIDE(__STABSTR_END__ = .);
9886 		BYTE(0)		/* Force the linker to allocate space
9887 				   for this section */
9888 	}
9889 
9890 	/* Adjust the address for the data segment to the next page */
9891 	. = ALIGN(0x1000);
9892 
9893 	/* Conventionally, Unix linkers provide pseudo-symbols
9894 	 * etext, edata, and end, at the end of the text, data, and bss.
9895 	 * For the kernel mapping, we need the address at the beginning
9896 	 * of the data section, but that's not one of the conventional
9897 	 * symbols, because the convention started before there was a
9898 	 * read-only rodata section between text and data. */
9899 	PROVIDE(data = .);
9900 	/* The data segment */
9901 	.data : {
9902 		*(.data)
9903 	}
9904 
9905 	PROVIDE(edata = .);
9906 
9907 	.bss : {
9908 		*(.bss)
9909 	}
9910 
9911 	PROVIDE(end = .);
9912 
9913 	/DISCARD/ : {
9914 		*(.eh_frame .note.GNU-stack)
9915 	}
9916 }
9917 
9918 
9919 
9920 
9921 
9922 
9923 
9924 
9925 
9926 
9927 
9928 
9929 
9930 
9931 
9932 
9933 
9934 
9935 
9936 
9937 
9938 
9939 
9940 
9941 
9942 
9943 
9944 
9945 
9946 
9947 
9948 
9949 
